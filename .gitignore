import Result from '#features/shared/result.js';

export default class FeeCaseGetByCifUseCase {
  async execute({ cif }, feeManagementModel, customerModel) {
    const [errCustomer, responseCustomer] = await customerModel.getCustomerDetailsByCif(cif);
    if (errCustomer) {
      return Result.fail({ message: "It's not possible to get address cif" });
    }

    const customerData = responseCustomer?.data?.customer || {};
    const [errFee, responseFee] = await feeManagementModel.getFeeByAccount(customerData);
    if (errFee) {
      return Result.fail({ message: "It's not possible to get fee values" });
    }


    function unifyFieldShape(field) {
      return {
        code: field.code ?? "",
        name: field.name ?? "",
        defaultValue: field.defaultValue ?? "",
        labelValue: field.labelValue ?? "",
        isException: field.isException ?? false,
        exceptionOptions: field.exceptionOptions ?? [],
        hasChanged: field.hasChanged ?? false,
        createdAt: field.createdAt ?? "",
        updatedAt: field.updatedAt ?? "",
        id: field.id ?? "",
        isStandard: field.isStandard ?? false,
        isCurrentClient: field.isCurrentClient ?? false,
        tooltip: field.tooltip ?? ""
      };
    }

    function unifyFeeGroupShape(group) {
      return {
        name: group.name ?? "",
        accountNumber: group.accountNumber ?? "",
        cif: group.cif ?? "",
        kycMailingStatus: group.kycMailingStatus ?? "",
        fields: Array.isArray(group.fields)
          ? group.fields.map(unifyFieldShape)
          : []
      };
    }


    function normalizeFeeName(text = "") {
      return text
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/[_-]/g, ' ')
        .trim();
    }

    const feesData = responseFee?.data || {};
    const timestamp = new Date().toISOString();

    const packageName = feesData.feePackage || "N/A";
    const packageType = feesData.defaultPackageType || "N/A";
    const branchType = feesData.branchType || "N/A";

    const currentFees = [
      ...(customerData?.customerCurrentFees?.map(x => ({
        feeDescription: x.feeDescription || '',
        feeCode: x.feeCode || ''
      })) || []),
      ...(feesData?.currentFees || [])
    ];

    const feeTypeMap = {
      1: "Customer Fees",
      2: "Bank Account Fees",
      3: "Investment Account Fees"
    };


    const rawCustomerAccounts = customerData?.customerAccount || [];
    const filteredCustomerAccounts = rawCustomerAccounts.filter(acc => {
      const feeTypeString = feeTypeMap[acc.feeType] || "";
      return ["Customer Fees", "Bank Account Fees", "Investment Account Fees"].includes(feeTypeString);
    });


    const formattedFeesFromCustomer = filteredCustomerAccounts.map(acc => {
      const normalizedName = normalizeFeeName(acc.feeDescription);

      const field = {
        code: acc.feeCode || "",
        name: normalizedName,
        defaultValue: acc.feeAmount?.toString() || "",
        labelValue: acc.feeAmount > 0 ? `$${acc.feeAmount.toFixed(2)}` : "",
        isException: acc.isFeesStandard === "No",
        exceptionOptions: [],
        hasChanged: false,
        createdAt: timestamp,
        updatedAt: timestamp,
        id: acc.ddaNumber?.toString() || "",
        isStandard: acc.isFeesStandard === "Yes",
        isCurrentClient: false,
        tooltip: acc.source ? `Source: ${acc.source}` : ""
      };

      return {
        feeType: feeTypeMap[acc.feeType] || "",
        feeGroups: [
          unifyFeeGroupShape({
            name: acc.feeGroup === 1 ? "Client Current Fees" : "Standard Fees",
            accountNumber: acc.ddaNumber?.toString() ?? "",
            cif: acc.cifno?.toString() ?? "",
            kycMailingStatus: acc.kycMailingStatus ?? "",
            fields: [field]
          })
        ]
      };
    });


    const formattedFeeGroupsFromData =
      feesData?.fees?.map(fg => ({
        feeType: fg.feeType || "",
        feeGroups: fg.feeGroups?.map(g => unifyFeeGroupShape(g)) || []
      })) || [];

    const allFees = [...formattedFeesFromCustomer, ...formattedFeeGroupsFromData];


    const feeTypesToReturn = ["Customer Fees", "Bank Account Fees", "Investment Account Fees"];

    const groupedFees = feeTypesToReturn.map(type => {
      const itemsOfThisType = allFees.filter(item => item.feeType === type);

      const combinedGroups = itemsOfThisType.flatMap(item => item.feeGroups || []);

      return {
        feeType: type,
        feeGroups: combinedGroups
      };
    });

    const result = {
      customerName: customerData?.customerAddress?.name || feesData?.customerName || '',
      customerShortName: feesData?.customerShortName || '',
      customerAddress: customerData?.customerAddress?.address || '',
      customerAccountOfficer: customerData?.customerAddress?.officer || '',
      cif: customerData?.customerAddress?.cif || cif,
      officerId: feesData?.officerId || '',
      branchCity: feesData?.branchCity || '',
      branchState: feesData?.branchState || '',
      branchType,
      feePackage: feesData?.feePackage || '',
      defaultFeePackageId: feesData?.defaultFeePackageId || '',
      defaultPackageType: feesData?.defaultPackageType || '',
      packageName,
      packageType,
      fees: groupedFees,
      feesActives: feesData?.feesActives || [],
      documentUrl: feesData?.documentUrl || '',
      currentFees
    };

    global.logger.info('End process');
    return Result.ok(result)
  }
}
