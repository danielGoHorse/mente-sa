import Result from '#features/shared/result.js'
import { FeeCase } from '#src/models/entities/FeeCase.js'
import { connectToFeeMgmtDb, executeStoreProcedure } from '#core/data/mssql/index.js'

function formatMessage(result, userNameFull, updatedAt) {
  return `${result} by ${userNameFull} on ${new Date(
    updatedAt
  ).toLocaleDateString('en-US')}`
}

function findApprover(field, approver) {
  global.logger.info('findApprover()')
  const result = field.results.get(approver.userName.toUpperCase())
  if (!result) return null

  const message = formatMessage(result, approver.userNameFull, approver.updatedAt)
  return {
    message,
    approved: result === 'Approved',
    note: field.rejectComment
  }
}

function processCommonApprover(feeCase, feeGroup, commonApprover) {
  global.logger.info('processCommonApprover()')
  const approvers = []

  const field = feeGroup.fields.find(
    (fld) => fld.hasChanged && (fld.approved || fld.reject)
  )
  if (!field) return approvers

  if (!field.results) {
    field.results = {}
  } else {
    const commonApproverResult = findApprover(field, commonApprover)
    if (commonApproverResult) {
      approvers.push(commonApproverResult)
    }

    const equityApprover = feeCase.equityTeam.find((user) => user.result)
    if (equityApprover) {
      const equityField = feeGroup.fields.find(
        (fld) =>
          fld.results &&
          !!fld.results.get(equityApprover.userName.toUpperCase())
      )

      if (equityField) {
        const equityApproverResult = findApprover(equityField, equityApprover)
        if (equityApproverResult) {
          approvers.push(equityApproverResult)
        }
        equityField.results = Object.fromEntries(field.results)
      }
    }

    if (field.results instanceof Map) {
      field.results = Object.fromEntries(field.results)
    }
  }

  return approvers
}

function resetLastFieldBasedOnConditions(lastField, lastOption, feeCase) {
  if (
    lastOption.text === 'Other' &&
    lastOption.value !== '' &&
    feeCase.status === 'PENDING_EQUITY' &&
    lastField.approved
  ) {
    delete lastField.approved
    delete lastField.reject
    delete lastField.rejectComment
  }
}

// Caso queira uma função auxiliar para documentUrl
function getDocumentUrl() {
  return global.environment?.documentUrl || 
    'https://minio-ui.dev.k8s.safra.int/api/v1/buckets/jarvis-public/objects/download?preview=true&prefix=U2NoZWR1bGVPZkZlZXMucGRm'
}

// ---- NOVO: Mapeia FeeType do DB p/ front, se precisar
function mapDbFeeTypeToApp(feeTypeFromDb) {
  switch (feeTypeFromDb) {
    case 'Client Fees':
      return 'Customer Fees'
    case 'Bank Account Fees':
      return 'Bank Account Fees'
    case 'Investment Fees':
      return 'Investment Account Fees'
    default:
      return feeTypeFromDb
  }
}

// ---- NOVO: Exemplo de método p/ buscar dados de conta via sp_get_fees_byCIF
async function getAccountsFromSQL(cifno) {
  const connection = await connectToFeeMgmtDb()
  const data = await executeStoreProcedure(connection, 'sp_get_fees_byCIF', { cifno })

  if (!data || data.length === 0) return []

  // Exemplo de map para accounts (similar ao FeeGetByCifUseCase)
  const accounts = data.map((row) => ({
    cifno: row.CIFNO,
    ddaNumber: row.ACCTNO,
    branchCity: row['Branch City'],
    branchState: row['Branch State'],
    branchType: row['Branch Type'],
    defaultPackageType: row['Default Package Type'],
    feePackage: row['Default Fee Package']?.trim() || '',
    documentUrl: getDocumentUrl(), 
    // Se quiser a mesma lógica do feePackageId => docUrl, ajusta aqui
  }))

  // Se quiser remover duplicados:
  const uniqueByDda = new Map()
  for (const acc of accounts) {
    uniqueByDda.set(acc.ddaNumber, acc)
  }

  return Array.from(uniqueByDda.values())
}

// ----

export default class FeeCaseGetByIdAndUserNameUseCase {
  async execute({ feeId, userName }) {
    global.logger.info(`FeeCaseGetByIdAndUserNameUseCase(fee=${feeId}, userName=${userName})`)

    const strategyForStatus = {
      INITIAL: 'usersApprovers',
      PENDING_APPROVAL: 'usersApprovers',
      PENDING_EQUITY: 'equityTeam',
      PENDING_SECOPS: 'secopsTeam',
      VISIBLE_ONLY: 'visibleToUsers'
    }

    const strategyForApprover = {
      INITIAL: 'canApprove',
      PENDING_APPROVAL: 'canApprove',
      PENDING_EQUITY: 'canEditEquity',
      PENDING_SECOPS: 'canEditSecops'
    }

    // Verifica se existe
    const hasFee = await FeeCase.exists({ _id: feeId })
    if (!hasFee) {
      return Result.fail('Fee case not found')
    }

    // Carrega do banco e converte em objeto
    const feeCase = await (await FeeCase.findById(feeId)).toObject()

    // A) Pegamos os accounts do DB via a mesma sp_get_fees_byCIF, usando feeCase.cif
    const accounts = await getAccountsFromSQL(feeCase.cif)

    // B) Injetamos no feeCase, p/ retornar ao front
    feeCase.accounts = accounts

    // feesActives
    const feesActives = await FeeCase.find({
      cif: feeCase.cif,
      status: { $nin: ['DONE', 'REJECTED'] },
      caseNumber: { $exists: true }
    })

    feeCase.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id
    }))

    // Se status != 'INITIAL' ou 'PENDING_APPROVAL', processa exceções
    if (!['INITIAL', 'PENDING_APPROVAL'].includes(feeCase.status)) {
      feeCase.fees.forEach((fee) => {
        fee.feeGroups.forEach((feeGroup) => {
          if (feeGroup.name !== 'Exception Request') return

          const lastField = feeGroup.fields.slice(-1)[0]
          const lastOption = lastField.exceptionOptions.slice(-1)[0]

          const commonApprover = feeCase.usersApprovers.find((user) => user.result)
          if (commonApprover) {
            feeGroup.approvalResults = processCommonApprover(feeCase, feeGroup, commonApprover)
          }
          resetLastFieldBasedOnConditions(lastField, lastOption, feeCase)
        })
      })
    }

    // Lógica de canApprove
    if (feeCase?.userOwner?.toUpperCase() === userName?.toUpperCase()) {
      feeCase.canApprove = false
      return Result.ok(feeCase)
    }

    const userListProperty = strategyForStatus[feeCase.status]
    const canApproveProperty = strategyForApprover[feeCase.status]

    if (
      feeCase[userListProperty] &&
      feeCase[userListProperty].some(
        (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
      )
    ) {
      feeCase[canApproveProperty] = true

      if (
        feeCase.status === 'PENDING_APPROVAL' &&
        feeCase[userListProperty]
          .filter((x) => x.userName?.toUpperCase() === userName?.toUpperCase())[0]
          ?.signature.includes('AAA')
      ) {
        feeCase.canSeeRevenueReport = true
      }

      return Result.ok(feeCase)
    }

    const propertys = Object.keys(strategyForStatus)
    let canSeeCase = false
    for (const property of propertys) {
      const userProperty = strategyForStatus[property]
      if (
        feeCase[userProperty] &&
        feeCase[userProperty].some(
          (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
        )
      ) {
        canSeeCase = true
        break
      }
    }

    if (canSeeCase) {
      return Result.ok(feeCase)
    }

    return Result.fail('Not found')
  }
}
