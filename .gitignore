// src/models/InvestmentAccountFee.js

import { FeeGroup } from './entities/FeeGroups.js'
import numberToCurrency from '../core/helpers/currency.js'

export default class InvestmentAccountFee {
  #feeName = 'Investment Account Fees';
  #investiment = {};
  #accounts = [];
  #accountsDDA = [];
  #allExceptions = new Set();

  constructor(fees, accounts, equityField) {
    // 1. Localiza o objeto em 'fees' cujo feeType seja "Investment Account Fees"
    this.#investiment = fees.filter((x) => x.feeType === this.#feeName)[0];

    // Se não achar ou se feeGroups estiver vazio, não há o que processar
    if (!this.#investiment || !Array.isArray(this.#investiment.feeGroups) || this.#investiment.feeGroups.length === 0) {
      this.#investiment = {};
      return;
    }

    // 2. Identifica o code do primeiro feeGroup (geralmente 1 => Standard Fees)
    const feeGroupCode = this.#investiment.feeGroups[0].code;

    // 3. Filtra as contas (accounts) que correspondem a esse feeGroup
    this.#accounts = accounts.filter((x) => x.feeGroup === feeGroupCode);

    if (this.#accounts.length < 1) {
      // Se não há contas, não há dados de Investment
      this.#investiment = {};
      return;
    }

    // 4. Cria um "Set" para armazenar as contas DDA sem 'bpsFeeTypeCode = O'
    //    Ajuste essas propriedades conforme seu DB (bpsAcctNumber, entity, etc.)
    this.#accountsDDA = new Set(
      accounts
        .filter((x) => x.feeGroup === feeGroupCode && x.bpsFeeTypeCode !== 'O')
        .map((x) => ({
          number: x.bpsAcctNumber,
          code: x.feeType,
          entity: x.entity
        }))
    );

    // 5. Cria múltiplos feeGroups (um por conta DDA)
    this.#addMultiplesAccount(this.#accounts[0].cifno);

    // 6. Ajusta valores e exceptions (caso necessário), usando equityField
    this.#addCurrentClientValue(equityField);
  }

  /**
   * Retorna o objeto final que será incluído em "result.fees"
   */
  get fee() {
    // Se estiver vazio, retorne null ou objeto vazio
    if (!this.#investiment || !this.#investiment.feeGroups) {
      return null;
    }
    return this.#investiment;
  }

  /**
   * Monta os feeGroups por accountNumber
   */
  #addMultiplesAccount(cif) {
    const result = {};

    // Para cada feeGroup existente (Standard, Client, Exceptions, etc.)
    for (const feeGroup of this.#investiment.feeGroups) {
      // Para cada conta DDA armazenada
      for (const account of this.#accountsDDA) {
        if (!result[account.number]) {
          result[account.number] = {};
        }

        // Filtra os fields cujo "code" bate com a feeType da conta
        const fields = feeGroup.fields.filter((x) => x.code === account.code);

        if (fields.length === 0) continue; // Se não achou nenhum field, pula

        // Se ainda não existe esse feeGroup dentro do result[account.number]
        if (!result[account.number][feeGroup.name]) {
          result[account.number][feeGroup.name] = [];

          // Filtra e guarda as exceptionsOptions (removendo as "retired")
          feeGroup.fields?.forEach((item) => {
            // Adiciona todas as exceptionOptions num Set global (#allExceptions)
            item.exceptionOptions.forEach(this.#allExceptions.add, this.#allExceptions);
            item.exceptionOptions = item.exceptionOptions.filter((x) => !x.retired);
          });

          // Cria uma instância de FeeGroup (importada de ./entities/FeeGroups.js)
          const newFeeGroup = new FeeGroup({
            name: feeGroup.name,
            fields,
            cif,
            accountNumber: account.number,
            visible: feeGroup.visible,
            code: feeGroup.code,
            entityCode: account.entity
          });

          // Armazena
          result[account.number][feeGroup.name].push(newFeeGroup);
          continue;
        }

        // Caso já exista esse group, só adicionamos esses fields lá
        const feeGroupToAddFields = result[account.number][feeGroup.name][0];
        feeGroupToAddFields.fields = [...feeGroupToAddFields.fields, ...fields];
      }
    }

    // Agora precisamos transformar esse objeto "result" num array de feeGroups
    const feeGroupsByAccount = Object.keys(result).reduce((acc, accountNumber) => {
      const groupNames = Object.keys(result[accountNumber]);
      groupNames.forEach((groupName) => {
        acc.push(result[accountNumber][groupName]);
      });
      return acc;
    }, []);

    // Substitui os feeGroups originais pelo novo array (cada accountNumber terá seu próprio set)
    this.#investiment.feeGroups = [];
    for (const feeGroups of feeGroupsByAccount) {
      for (const feeGroup of feeGroups) {
        this.#investiment.feeGroups.push(feeGroup);
      }
    }
  }

  /**
   * Ajusta valores de "defaultValue", "labelValue" e exceptions
   */
  #addCurrentClientValue(equityField) {
    // Converter o Set de exceptions para array
    const exceptionsOptions = Array.from(this.#allExceptions);

    for (const [feeGroupIndex, feeGroup] of this.#investiment.feeGroups.entries()) {
      // Ajusta CIF (caso necessário)
      feeGroup.cif = this.#accounts[0]?.cifno || null;

      // Para cada field do feeGroup
      for (const [fieldIndex, field] of feeGroup.fields.entries()) {
        // Se é um field "isException"
        if (field.isException) {
          // Tenta "copiar" o labelValue do feeGroup anterior (depende da sua lógica)
          if (feeGroupIndex > 0) {
            field.labelValue =
              this.#investiment.feeGroups[feeGroupIndex - 1].fields[fieldIndex]?.labelValue || '';
          }
        } else {
          // Se não for exception, precisa mapear com a conta certa
          for (const account of this.#accounts) {
            // Verifica se o code do field bate com a feeType da conta
            // e se a conta atual bate com o accountNumber
            if (
              field.code === account.feeType &&
              feeGroup.accountNumber === account.bpsAcctNumber
            ) {
              // Exemplo: se field.code = 5, tratar de forma especial
              if (field.code === 5) {
                field.defaultValue = field.isStandard
                  ? field.defaultValue
                  : account.feeAmount?.toString() || '';
                field.labelValue = numberToCurrency(field.defaultValue);
              } else {
                // Se labelValue não for "Other", checa se é "isCurrentClient"
                if (field.labelValue !== 'Other') {
                  if (field.isCurrentClient) {
                    field.defaultValue = account.feeCode?.toString() || '';
                  }

                  // Tenta achar a exception no array local
                  let exception = exceptionsOptions.find((x) => x.value === field.defaultValue);

                  // Se não achar, tenta no equityField
                  if (!exception && equityField?.exceptionOptions) {
                    exception = equityField.exceptionOptions.find(
                      (e) => e.value === field.defaultValue
                    );
                  }

                  // Se ainda não achar, define um objeto vazio
                  if (!exception) {
                    exception = { text: '' };
                  }

                  field.labelValue = exception.text;
                }
              }
            }
          }
        }
      }
    }

    // Limpa arrays e Sets
    this.#clearMemory();
  }

  /**
   * Reseta variáveis privadas para evitar reuso
   */
  #clearMemory() {
    this.#accounts = [];
    this.#accountsDDA = [];
    this.#allExceptions = new Set();
  }
}
