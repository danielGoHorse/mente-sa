import Result from '#features/shared/result.js';
import CustomerFees from '#src/models/CustomerFees.js';
import BankAccountFee from '#src/models/BankAccountFee.js';
import { FeeCase } from '#src/models/entities/FeeCase.js';
import {
  connectToFeeMgmtDb,
  executeStoreProcedure,
} from '#core/data/mssql/index.js';

const deParaFeeCodes = {
  JH001: 1,
  JH002: 2,
  JH006: 4,
  JH007: 8,
  BPS002: 6,
  BPS003: 5,
  BPS004: 7,
  BPS005: 7,
  JH010: 3,
};

const deParaFeePackageId = {
  1: 'intlPB3',
  2: 'uSPBIndividual3',
  3: 'uSPBCorporation3',
  4: 'efraPB3',
  5: 'eraPB3',
};

const excludedCodes = new Set([8]);

export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    const result = { fees: [] };

    const { groupedFees, accounts } = await this.#getFeesStructuredFromSQL(
      customerAccount
    );

    result.accounts = accounts.map((account) => ({
      cifno: account.cifno,
      ddaNumber: account.ddaNumber,
      branchCity: account.branchCity,
      branchState: account.branchState, 
      branchType: account.branchType, 
      defaultPackageType: account.defaultPackageType, 
      feePackage: account.feePackage, 
    }));

    const customer = new CustomerFees(groupedFees, accounts);
    if (customer.fee) result.fees.push(customer.fee);

    const bank = new BankAccountFee(groupedFees, accounts);
    if (bank.fee) result.fees.push(bank.fee);


    let investmentGroup = groupedFees['Investment Account Fees'];
    if (investmentGroup) {
      const equityFields = accounts.filter((account) => account.feeType === 3);
      equityFields.forEach((field) => {
        let investmentGroupFields = investmentGroup.feeGroups.find((group) => group.name === 'Standard Fees');
        if (!investmentGroupFields) {
          investmentGroupFields = {
            name: 'Standard Fees',
            code: 1,
            fields: [],
          };
          investmentGroup.feeGroups.push(investmentGroupFields);
        }

        investmentGroupFields.fields.push({
          code: field.code,
          name: field.name || 'Equity and Options Commission',
          defaultValue: field.defaultValue || '',
          tooltip: field.tooltip || '',
          isException: field.isException || false,
        });
      });

      result.fees.push(investmentGroup);
    }


    const feesActives = await FeeCase.find({
      cif: customerAccount[0].cifno,
      status: {
        $nin: ['DONE', 'REJECTED'],
      },
      caseNumber: {
        $exists: true,
      },
    });

    result.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id,
    }));


    return Result.ok(result);
  }


  async #getFeesStructuredFromSQL(customerAccount) {
    const feesData = await this.#getFeesFromSQL(customerAccount[0].cifno);
  
    const feePackageId = feesData[0]?.['Default Fee Package Id'];
    if (!feePackageId) {
      throw new Error('Default Fee Package Id not found in feesData');
    }
  
    const documentUrl = this.#getDocumentUrl(feePackageId);
  
    const accounts = feesData.map((fee) => ({
      cifno: fee.CIFNO,
      ddaNumber: fee.ACCTNO,
      branchCity: fee['Branch City'],
      branchState: fee['Branch State'],
      branchType: fee['Branch Type'],
      defaultPackageType: fee['Default Package Type'],
      feePackage: fee['Default Fee Package']?.trim() || '',
      defaultFeePackageId: fee['Default Fee Package Id'] || '',
      feeType: this.#mapFeeType(fee.FeeType),
      feeGroup: 1,
      kycMailingStatus: fee.StandardException === 'Standard' ? 'Standard' : 'Hold Mail',
      documentUrl,
    }));
  
    const groupedFees = {};
  
    for (const fee of feesData) {
      const {
        FeeType,
        FeeDescription,
        FeeCode,
        FeeAmount,
        Frequency,
        DefaultFeeAmount,
        DefaultFrequency,
      } = fee;
  
      const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;
  
      if (
        (FeeType === 'Customer Fees' && ![1, 2].includes(mappedCode)) ||
        (FeeType === 'Bank Account Fees' && ![3, 4].includes(mappedCode)) ||
        (FeeType === 'Investment Account Fees' && ![5, 6, 7].includes(mappedCode)) ||
        excludedCodes.has(mappedCode)
      ) {
        continue;
      }
  
      if (!groupedFees[FeeType]) {
        groupedFees[FeeType] = {
          feeType: FeeType,
          feeGroups: [],
        };
      }
  
      let standardGroup = groupedFees[FeeType].feeGroups.find(
        (group) => group.name === 'Standard Fees'
      );
      if (!standardGroup) {
        standardGroup = {
          name: 'Standard Fees',
          code: 1,
          fields: [],
        };
        groupedFees[FeeType].feeGroups.push(standardGroup);
      }
  
      standardGroup.fields.push({
        code: mappedCode,
        name: FeeDescription,
        defaultValue: FeeAmount ? FeeAmount.toString() : '',
        tooltip: Frequency ? Frequency : '',
        isException: false,
      });
  
      let clientCurrentGroup = groupedFees[FeeType].feeGroups.find(
        (group) => group.name === 'Client Current Fees'
      );
      if (!clientCurrentGroup) {
        clientCurrentGroup = {
          name: 'Client Current Fees',
          code: 2,
          fields: [],
        };
        groupedFees[FeeType].feeGroups.push(clientCurrentGroup);
      }
  
      clientCurrentGroup.fields.push({
        code: mappedCode,
        name: FeeDescription,
        defaultValue: DefaultFeeAmount ? DefaultFeeAmount.toString() : '',
        tooltip: DefaultFrequency ? DefaultFrequency : '',
        isException: false,
      });
    }
  
    const exceptions = await this.#getExceptionFeesFromSQL(feePackageId);
  
    for (const exception of exceptions) {
      const { code, name, defaultValue, tooltip, isException } = exception;
  
      const feeType = Object.keys(groupedFees).find((type) =>
        groupedFees[type].feeGroups.some((group) =>
          group.fields.some((field) => field.code === code)
        )
      );
  
      if (!feeType) {
        continue;
      }
  
      let exceptionGroup = groupedFees[feeType]?.feeGroups.find(
        (group) => group.name === 'Exceptions Request'
      );
  
      if (!exceptionGroup) {
        exceptionGroup = {
          name: 'Exceptions Request',
          code: 3,
          fields: [],
        };
        groupedFees[feeType]?.feeGroups.push(exceptionGroup);
      }
  
      let existingField = exceptionGroup.fields.find((field) => field.code === code);
  
      if (!existingField) {
        existingField = {
          code,
          name,
          defaultValue,
          tooltip,
          isException,
          exceptionOptions: [],
        };
        exceptionGroup.fields.push(existingField);
      }
  
      // Filtro de opções válidas
      existingField.exceptionOptions.push({
        code,
        name,
        defaultValue,
        tooltip,
        isException,
        retired: false, // Padrão ao adicionar novas opções
        visible: true,
      });
    }
  
    return { groupedFees: Object.values(groupedFees), accounts };
  }


#getDocumentUrl(feePackageId) {

  const packageKeyMap = {
    1: 'intlPB3',
    2: 'uSPBIndividual3',
    3: 'uSPBCorporation3',
    4: 'efraPB3',
    5: 'eraPB3',
  };
  const packageKey = packageKeyMap[feePackageId]
  return packageKey ? global.environment.scheduleUrls?.[feePackageId] || '' : '';
}

  #mapFeeType(feeType) {
    switch (feeType) {
      case 'Customer Fees':
        return 1;
      case 'Bank Account Fees':
        return 2;
      case 'Investment Account Fees':
        return 3;
      default:
        return 0;
    }
  }

  async #getFeesFromSQL(cifno) {
    const connection = await connectToFeeMgmtDb();
    return executeStoreProcedure(connection, 'sp_get_fees_byCIF', { cifno });
  }

  async #getExceptionFeesFromSQL(feePackageId) {
    const connection = await connectToFeeMgmtDb();
    const data = await executeStoreProcedure(
      connection,
      'sp_get_exception_fees_bypackage',
      { feePackageId }
    );

    return data.map((exception) => ({
      code: deParaFeeCodes[exception.FeeCode] || exception.FeeCode,
      name: exception.FeeDescription,
      defaultValue: exception.Amount?.toString() || '0',
      tooltip: exception.FreqDescription || '',
      isException: true,
    }));
  }
}
