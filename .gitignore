import Result from '#features/shared/result.js';

export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    const cif = customerAccount[0]?.cifno;
    const feePackageId = customerAccount[0]?.feePackageId;

    if (!cif) {
      return Result.fail({ message: "CIF não informado" });
    }

    global.logger.info(`Fetching fees for CIF: ${cif}`);

    // Buscar Fees pelo CIF no SQL
    const feesData = await this.#getFeesFromSQL(cif);
    if (!feesData || feesData.length === 0) {
      return Result.fail({ message: "It's not possible to get fee values" });
    }

    // Buscar Exceptions pelo FeePackageId
    let exceptionFees = [];
    if (feePackageId) {
      global.logger.info(`Fetching exceptions for FeePackageId: ${feePackageId}`);
      exceptionFees = await this.#getExceptionFeesFromSQL(feePackageId);
      if (!exceptionFees) {
        return Result.fail({ message: "It's not possible to get exception fee values" });
      }
    }

    // Mock de dados que ainda não existem na base SQL
    const feesActives = [
      { caseNumber: "12345", id: "mocked-active-fee-1" },
      { caseNumber: "67890", id: "mocked-active-fee-2" },
    ];

    // Construindo `documentUrl`
    const documentUrl = this.#getDocumentUrl(feePackageId);

    // Organizar os dados básicos do cliente
    const customerInfo = {
      customerName: customerAccount[0]?.customerName || '',
      customerShortName: customerAccount[0]?.customerShortName || '',
      customerAddress: customerAccount[0]?.customerAddress || '',
      customerAccountOfficer: customerAccount[0]?.customerAccountOfficer || '',
      cif,
      officerId: customerAccount[0]?.officerId || '',
      branchCity: customerAccount[0]?.branchCity || '',
      branchState: customerAccount[0]?.branchState || '',
      branchType: customerAccount[0]?.branchType || '',
      feePackage: customerAccount[0]?.feePackage || '',
      defaultFeePackageId: feePackageId || '',
    };

    // Construindo `currentFees`
    const currentFees = exceptionFees.map(fee => ({
      feeDescription: fee.FeeDescription,
      feeCode: fee.FeeCode,
      amount: fee.Amount,
      frequency: fee.FreqDescription || 'Mocked Frequency',
    }));

    // Montando o payload final
    const result = {
      ...customerInfo,
      fees: this.#organizeFees(feesData),
      feesActives,
      documentUrl,
      currentFees,
    };

    global.logger.info("Processamento finalizado com sucesso");
    return Result.ok(result);
  }

  /**
   * Busca as taxas no SQL pelo CIF
   */
  async #getFeesFromSQL(cifno) {
    global.logger.info('getFeesFromSQL()');
    const connection = await connectToFeeMgmtDb();
    const recordset = await executeStoreProcedure(connection, 'sp_get_fees_byCIF', { cifno });
    return recordset?.data || [];
  }

  /**
   * Busca as exceções de taxas no SQL pelo FeePackageId
   */
  async #getExceptionFeesFromSQL(feePackageId) {
    global.logger.info('getExceptionFeesFromSQL()');
    const connection = await connectToFeeMgmtDb();
    const recordset = await executeStoreProcedure(connection, 'sp_get_exception_fees_bypackage', { feePackageId });
    return recordset?.data || [];
  }

  /**
   * Organiza os dados das taxas em `feeType` e `feeGroups`
   */
  #organizeFees(feesData) {
    const groupedFees = {};

    feesData.forEach(fee => {
      const feeType = fee.FeeType || "Unknown Fees";
      if (!groupedFees[feeType]) {
        groupedFees[feeType] = {
          feeType,
          feeGroups: [],
          id: `fee-type-${feeType.replace(/\s/g, "-").toLowerCase()}`,
        };
      }

      let feeGroup = groupedFees[feeType].feeGroups.find(
        group => group.accountNumber === fee.ACCTNO
      );

      if (!feeGroup) {
        feeGroup = {
          name: "Standard Fees",
          code: fee.ACCTNO,
          fields: [],
          cif: fee.CIFNO,
          accountNumber: fee.ACCTNO,
          visible: true,
          kycMailingStatus: null,
          id: `fee-group-${fee.ACCTNO}`,
        };
        groupedFees[feeType].feeGroups.push(feeGroup);
      }

      feeGroup.fields.push({
        code: fee.FeeCode,
        name: fee.FeeDescription,
        isStandard: fee.StandardException === "Standard",
        isCurrentClient: fee.StandardException === "Client",
        isException: fee.StandardException === "Exception",
        defaultValue: fee.FeeAmount?.toString() || "0",
        hasChanged: false,
        tooltip: `Charged: ${fee.Frequency || "N/A"}`,
        exceptionOptions: [],
        id: `fee-field-${fee.FeeCode}`,
        labelValue: `$${fee.FeeAmount || "0.00"}`,
      });
    });

    return Object.values(groupedFees);
  }

  /**
   * Retorna a URL do documento baseado no `feePackageId`
   */
  #getDocumentUrl(feePackageId) {
    const scheduleUrls = global.environment.scheduleUrls;
    const packageMap = {
      1: 'intlPB3',
      2: 'uSPBIndividual3',
      3: 'uSPBCorporation3',
      4: 'efraPB3',
      5: 'eraPB3'
    };

    const scheduleType = packageMap[feePackageId] || '';
    return scheduleUrls[scheduleType] || '';
  }
}
