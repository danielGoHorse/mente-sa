import { FeeGroup } from './entities/FeeGroups.js';
import numberToCurrency from '../core/helpers/currency.js';

export default class CustomerFees {
  #feeName = 'Customer Fees';
  #customer = {};
  #accounts = [];

  constructor(fees, accounts) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }
    // Seleciona "Customer Fees"
    this.#customer = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (!this.#customer || !Array.isArray(this.#customer.feeGroups)) {
      throw new Error('Customer Fees or feeGroups are undefined');
    }
    if (!accounts || !Array.isArray(accounts) || accounts.length === 0) {
      throw new Error('Accounts is empty or undefined');
    }
    // Mantemos só a primeira conta (se for a lógica do seu caso)
    this.#accounts = [accounts[0]];

    this.#addMultiplesAccount(this.#accounts[0].cifno);
    this.#addCurrentClientValue();
  }

  /**
   * Deduplica fields por code.
   */
  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  /**
   * Clona os feeGroups, define kycMailingStatus e atribui ao #customer.feeGroups.
   */
  #addMultiplesAccount(cif) {
    const feeGroupTemplates = this.#customer.feeGroups;
    const newFeeGroups = [];

    for (const template of feeGroupTemplates) {
      let clonedFields = template.fields.map((field) => ({
        ...field,
        exceptionOptions: field.exceptionOptions
          ? field.exceptionOptions.map((opt) => ({ ...opt }))
          : []
      }));

      clonedFields = this.#deduplicateFields(clonedFields);

      const kycMailingStatus = this.#accounts[0].kycMailingStatus || 'Standard';

      const newFeeGroup = new FeeGroup({
        name: template.name,
        fields: clonedFields,
        cif,
        accountNumber: this.#accounts[0].ddaNumber.toString(),
        visible: template.visible,
        code: template.code,
        kycMailingStatus 
      });
      newFeeGroups.push(newFeeGroup);
    }

    this.#customer.feeGroups = newFeeGroups;
  }

  /**
   * Aplica "NOT APPLICABLE" se code=2 e kycMailingStatus=Standard,
   * não só em "Client Current Fees", mas também em "Exception Request".
   * Caso contrário, formata o valor monetariamente.
   */
  #addCurrentClientValue() {
    const kycStatus = this.#accounts[0].kycMailingStatus || 'Standard';
    for (const feeGroup of this.#customer.feeGroups) {
      for (const field of feeGroup.fields) {
        // Verifica se code=2 e kycMailingStatus=Standard
        // e se o grupo é "Client Current Fees" OU "Exception Request"
        if (
          (feeGroup.name === "Client Current Fees" || feeGroup.name === "Exception Request") &&
          kycStatus === "Standard" &&
          field.code === 2
        ) {
          field.defaultValue = "NOT APPLICABLE";
          field.labelValue = "NOT APPLICABLE";
        } else {
          field.labelValue = numberToCurrency(field.defaultValue);
        }
      }
    }
  }

  get fee() {
    return this.#customer;
  }
}
