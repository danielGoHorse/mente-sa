import Result from '#features/shared/result.js';
import CustomerFees from '#src/models/CustomerFees.js';
import BankAccountFee from '#src/models/BankAccountFee.js';
import InvestmentAccountFee from '#src/models/InvestmentAccountFee.js';
import { FeeCase } from '#src/models/entities/FeeCase.js';
import {
  connectToFeeMgmtDb,
  executeStoreProcedure,
} from '#core/data/mssql/index.js';

const deParaFeeCodes = {
  JH001: 1,
  JH002: 2,
  JH006: 4,
  JH007: 8,
  BPS002: 6,
  BPS003: 5,
  BPS004: 9,
  BPS005: 7,
  JH010: 3,
};

const excludedCodes = new Set([8]);

function mapDbFeeTypeToApp(feeTypeFromDb) {
  switch (feeTypeFromDb) {
    case 'Client Fees':
      return 'Customer Fees';
    case 'Bank Account Fees':
      return 'Bank Account Fees';
    case 'Investment Fees':
      return 'Investment Account Fees';
    default:
      return feeTypeFromDb;
  }
}

function mapFeeTypeToNumber(feeType) {
  switch (feeType) {
    case 'Customer Fees':
      return 1;
    case 'Bank Account Fees':
      return 2;
    case 'Investment Account Fees':
      return 3;
  }
}

export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    const result = { fees: [] };

    const { groupedFees, accounts } = await this.#getFeesStructuredFromSQL(customerAccount);

    result.accounts = accounts.map((account) => ({
      cifno: account.cifno,
      ddaNumber: account.ddaNumber,
      branchCity: account.branchCity,
      branchState: account.branchState,
      branchType: account.branchType,
      documentUrl: account.documentUrl,
      defaultPackageType: account.defaultPackageType,
      feePackage: account.feePackage,
    }));

    const customer = new CustomerFees(groupedFees, accounts);
    if (customer.fee) result.fees.push(customer.fee);

    const bank = new BankAccountFee(groupedFees, accounts);
    if (bank.fee) result.fees.push(bank.fee);

    const equityField = { exceptionOptions: [] };

    const investment = new InvestmentAccountFee(groupedFees, accounts, equityField);
    if (investment.fee) {
      result.fees.push(investment.fee);
    }

    const feesActives = await FeeCase.find({
      cif: customerAccount[0].cifno,
      status: { $nin: ['DONE', 'REJECTED'] },
      caseNumber: { $exists: true },
    });

    result.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id,
    }));

    return Result.ok(result);
  }

  async #getFeesStructuredFromSQL(customerAccount) {
    const feesDataRaw = await this.#getFeesFromSQL(customerAccount[0].cifno);
    if (!feesDataRaw || feesDataRaw.length === 0) {
      return { groupedFees: [], accounts: [] };
    }

    const feesData = Array.from(
      new Map(feesDataRaw.map(row => [
        `${row.CIFNO}-${row.ACCTNO}-${row.FeeCode}-${row.FeeType}`, row
      ])).values()
    );

    const feePackageId = feesData[0]['Default Fee Package Id'];
    if (!feePackageId) {
      throw new Error('Default Fee Package Id not found in feesData');
    }

    const documentUrl = this.#getDocumentUrl(feePackageId);

    const accounts = feesData.map((fee) => ({
      cifno: fee.CIFNO,
      ddaNumber: fee.ACCTNO,
      branchCity: fee['Branch City'],
      branchState: fee['Branch State'],
      branchType: fee['Branch Type'],
      defaultPackageType: fee['Default Package Type'],
      feePackage: fee['Default Fee Package']?.trim() || '',
      defaultFeePackageId: fee['Default Fee Package Id'] || '',
      feeType: mapFeeTypeToNumber(mapDbFeeTypeToApp(fee.FeeType)),
      feeGroup: 1,
      kycMailingStatus: fee.StandardException === 'Standard' ? 'Standard' : 'Hold Mail',
      documentUrl
    }));

    const groupedFeesMap = {};
    const possibleFeeTypes = ['Customer Fees', 'Bank Account Fees', 'Investment Account Fees'];
    for (const ft of possibleFeeTypes) {
      groupedFeesMap[ft] = {
        feeType: ft,
        feeGroups: [
          { name: 'Standard Fees', code: 1, fields: [] },
          { name: 'Client Current Fees', code: 2, fields: [] },
          { name: 'Exception Request', code: 3, fields: [] },
        ],
      };
    }

    for (const row of feesData) {
      const feeTypeDb = row.FeeType;
      const feeTypeApp = mapDbFeeTypeToApp(feeTypeDb);
      if (!groupedFeesMap[feeTypeApp]) continue;

      const { FeeDescription, FeeCode, FeeAmount, Frequency } = row;
      const DefaultFeeAmount = row["Default Fee Amount"];
      const DefaultFrequency = row["Default Frequency"];

      const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;
      if (excludedCodes.has(mappedCode)) continue;
      if (
        feeTypeApp === 'Customer Fees' && ![1, 2].includes(mappedCode) ||
        feeTypeApp === 'Bank Account Fees' && ![3, 4].includes(mappedCode) ||
        feeTypeApp === 'Investment Account Fees' && ![5, 7, 6, 9].includes(mappedCode)
      ) {
        continue;
      }

      const groupObj = groupedFeesMap[feeTypeApp];
      const standardGroup = groupObj.feeGroups.find((g) => g.name === 'Standard Fees');
      const clientCurrentGroup = groupObj.feeGroups.find((g) => g.name === 'Client Current Fees');

      standardGroup.fields.push({
        code: mappedCode,
        name: FeeDescription,
        defaultValue: FeeAmount ? FeeAmount.toString() : '',
        tooltip: Frequency || '',
        isException: false,
      });

      clientCurrentGroup.fields.push({
        code: mappedCode,
        name: FeeDescription,
        defaultValue: DefaultFeeAmount ? DefaultFeeAmount.toString() : '',
        tooltip: DefaultFrequency || '',
        isException: false,
      });
    }

    const exceptions = await this.#getExceptionFeesFromSQL(feePackageId);
    const exceptionsByFeeTypeAndCode = {};
    for (const exc of exceptions) {
      const feeTypeApp = exc.feeType;
      if (!exceptionsByFeeTypeAndCode[feeTypeApp]) {
        exceptionsByFeeTypeAndCode[feeTypeApp] = {};
      }
      const code = exc.code;
      if (!exceptionsByFeeTypeAndCode[feeTypeApp][code]) {
        exceptionsByFeeTypeAndCode[feeTypeApp][code] = [];
      }
      exceptionsByFeeTypeAndCode[feeTypeApp][code].push(exc);
    }

    for (const ft of possibleFeeTypes) {
      const groupObj = groupedFeesMap[ft];
      if (!groupObj) continue;

      const exceptionGroup = groupObj.feeGroups.find((g) => g.name === 'Exception Request');
      if (!exceptionGroup) continue;

      const standardGroup = groupObj.feeGroups.find((g) => g.name === 'Standard Fees');
      const clientCurrentGroup = groupObj.feeGroups.find((g) => g.name === 'Client Current Fees');
      const standardCodes = standardGroup?.fields.map((f) => f.code) || [];
      const clientCodes = clientCurrentGroup?.fields.map((f) => f.code) || [];
      const allCodes = new Set([...standardCodes, ...clientCodes]);

      for (const code of allCodes) {
        let field = exceptionGroup.fields.find((f) => f.code === code);
        if (!field) {
          const stdField = standardGroup?.fields.find((f) => f.code === code);
          field = {
            code,
            name: stdField?.name || '',
            defaultValue: '0',
            tooltip: '',
            isException: true,
            exceptionOptions: []
          };
          exceptionGroup.fields.push(field);
        } else {
          if (!field.name || field.name.trim() === '') {
            const stdField = standardGroup?.fields.find((f) => f.code === code);
            field.name = stdField?.name || '';
          }
        }
      }

      const codeMap = exceptionsByFeeTypeAndCode[ft] || {};

      for (const [codeStr, listExc] of Object.entries(codeMap)) {
        const code = Number(codeStr);

        if(excludedCodes.has(code)) continue;

        let field = exceptionGroup.fields.find((f) => f.code === code);
        if (!field) {
          const stdField = standardGroup?.fields.find((f) => f.code === code);
          field = {
            code,
            name: stdField?.name || listExc[0].name || '',
            defaultValue:'',
            tooltip: listExc[0].tooltip || '',
            isException: true,
            exceptionOptions: []
          };
          exceptionGroup.fields.push(field);
        } else {
          if (!field.name || field.name.trim() === '') {
            const stdField = standardGroup?.fields.find((f) => f.code === code);
            field.name = stdField?.name || listExc[0].name || '';
          }
          field.defaultValue = '';

        }
        for (const exc of listExc) {
          const amountNumber = parseFloat(exc.defaultValue || '0');
          field.exceptionOptions.push({
            approvedByDoubleA: null,
            value: exc.defaultValue,
            text:isNaN(amountNumber) ? exc.defaultValue : 
            `$${amountNumber.toFixed(2)}`,
            visible: true,
            retired: false,
            parameterOptionId: exc.parameterOptionId,
          });
        }
      }
    }

    const groupedFees = Object.values(groupedFeesMap);
    return { groupedFees, accounts };
  }

  #getDocumentUrl(feePackageId) {
    const scheduleUrls = global.environment.scheduleUrls;
    const packageMap = {
      1: 'intlPB3',
      2: 'uSPBIndividual3',
      3: 'uSPBCorporation3',
      4: 'efraPB3',
      5: 'eraPB3'
    };

    const scheduleType = packageMap[feePackageId] || '';
    return scheduleUrls[scheduleType] || '';
  }

  async #getFeesFromSQL(cifno) {
    const connection = await connectToFeeMgmtDb();
    return executeStoreProcedure(connection, 'sp_get_fees_byCIF', { cifno });
  }

  async #getExceptionFeesFromSQL(feePackageId) {
    const connection = await connectToFeeMgmtDb();
    const data = await executeStoreProcedure(connection, 'sp_get_exception_fees_bypackage', { feePackageId });
    return data.map((exception) => {
      const feeTypeApp = mapDbFeeTypeToApp(exception.FeeType);
      return {
        feeType: feeTypeApp,
        code: deParaFeeCodes[exception.FeeCode] || exception.FeeCode,
        name: exception.FeeDescription, 
        defaultValue: exception.Amount?.toString() || '0',
        tooltip: exception.FreqDescription || '',
        isException: true,
        parameterOptionId: exception.FeeParameterOptionId,
      };
    });
  }
}




import { FeeGroup } from './entities/FeeGroups.js';

export default class InvestmentAccountFee {
  #feeName = 'Investment Account Fees';
  #investiment = {};
  #accounts = [];
  #accountsDDA = [];
  #allExceptions = new Set();

  constructor(fees, accounts, equityField) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }
    this.#investiment = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (
      !this.#investiment ||
      !Array.isArray(this.#investiment.feeGroups) ||
      !this.#investiment.feeGroups.length
    ) {
      this.#investiment = {};
      return;
    }

    this.#accounts = accounts.filter((x) => x.feeType === 3);
    if (this.#accounts.length < 1) {
      this.#investiment = {};
      return;
    }

    this.#accounts.forEach((acc) => {
      if (acc.ddaNumber) {
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 5,
          entity: acc.entity || null,
        });
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 7,
          entity: acc.entity || null,
        });
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 6,
          entity: acc.entity || null,
        });
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 9,
          entity: acc.entity || null,
        });
      }
    });

    this.#accountsDDA = Array.from(
      new Map(this.#accountsDDA.map(item => [`${item.number}-${item.code}`, item])).values()
    );

    this.#addMultiplesAccount(this.#accounts[0].cifno);
    this.#addCurrentClientValue(equityField);
  }

  get fee() {
    if (!this.#investiment || !this.#investiment.feeGroups) {
      return null;
    }
    return this.#investiment;
  }

  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  #addMultiplesAccount(cif) {
    const result = {};

    for (const feeGroup of this.#investiment.feeGroups) {
      const clonedFields = (feeGroup.fields || []).map((field) => ({
        ...field,
        exceptionOptions: field.exceptionOptions
          ? field.exceptionOptions.map((opt) => ({ ...opt }))
          : []
      }));

      for (const account of this.#accountsDDA) {
        if (!result[account.number]) {
          result[account.number] = {};
        }
        let fieldsForAccount = clonedFields.filter((x) => x.code === account.code);
        if (fieldsForAccount.length === 0) {
          fieldsForAccount.push({
            code: account.code,
            name: '',
            defaultValue: '',
            tooltip: '',
            isException: true,
            exceptionOptions: []
          });
        }
        if (!result[account.number][feeGroup.name]) {
          const dedupedFields = this.#deduplicateFields(fieldsForAccount);
          const newFeeGroup = new FeeGroup({
            name: feeGroup.name,
            fields: dedupedFields,
            cif,
            accountNumber: account.number,
            visible: feeGroup.visible,
            code: feeGroup.code,
            entityCode: account.entity,
          });
          result[account.number][feeGroup.name] = newFeeGroup;
        } else {
          const existingFeeGroup = result[account.number][feeGroup.name];
          existingFeeGroup.fields = this.#deduplicateFields([
            ...existingFeeGroup.fields,
            ...fieldsForAccount,
          ]);
        }
      }
    }

    const feeGroupsArray = [];
    for (const accountNumber in result) {
      for (const groupName in result[accountNumber]) {
        feeGroupsArray.push(result[accountNumber][groupName]);
      }
    }
    this.#investiment.feeGroups = feeGroupsArray;
  }

  #addCurrentClientValue(equityField) {
    for (const feeGroup of this.#investiment.feeGroups) {
      feeGroup.cif = this.#accounts[0]?.cifno || null;
      for (const field of feeGroup.fields) {
        if (field.isException) {
          field.labelValue = field.labelValue || '';
        } else {
          if (
            feeGroup.name === "Client Current Fees" &&
            (field.code === 7 || field.code === 9 || field.code === 6) &&
            (!field.defaultValue || field.defaultValue.trim() === "")
          ) {
            field.defaultValue = field.tooltip || '';
            field.labelValue = field.defaultValue;
          } else {
            const corresponding = this.#accountsDDA.find(
              (acc) =>
                acc.number.toString() === feeGroup.accountNumber.toString() &&
                acc.code === field.code
            );
            if (corresponding) {
              if (field.code === 5) {
                const numValue = parseFloat(field.defaultValue);
                field.labelValue = !isNaN(numValue) ? "$" + numValue.toFixed(2) : field.defaultValue;
              } else if (feeGroup.name === "Standard Fees" && field.code === 6) {
                field.labelValue = field.defaultValue;
              } else {
                const numValue = parseFloat(field.defaultValue);
                field.labelValue = !isNaN(numValue) ? "$" + numValue.toFixed(2) : field.defaultValue;
              }
            }
          }
        }
      }
    }
    this.#clearMemory();
  }
  
  #clearMemory() {
    this.#accounts = [];
    this.#accountsDDA = [];
    this.#allExceptions = new Set();
  }
}
