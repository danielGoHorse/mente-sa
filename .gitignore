/* (…) importações e helpers que você já tinha … */

/* --------- Standard Fees ---------- */
function applyStandardAmounts(mongoFees, stdRows) {
  mongoFees.forEach(fee => {
    const stdGrp = findGroup(fee, 'Standard Fees');
    if (!stdGrp) return;

    stdGrp.fields.forEach(field => {
      const row = stdRows.find(r => Number(r.FeeType) === field.code);
      if (!row) return;

      const num = Number(row.FeeAmount);

      /* numérico → moeda | alfanumérico → descrição */
      if (!Number.isNaN(num)) {
        field.defaultValue = num.toString();
        field.labelValue   = numberToCurrency(num);
      } else {
        field.defaultValue = row.FeeAmount;                       // ex.: "A021"
        field.labelValue   = row.FrequencyDescription?.trim()
                         || row.FeeAmount;                        // fallback
      }
      field.tooltip = row.FrequencyDescription?.trim() || '';
    });
  });
}

/* --------- Exception Fees ---------- */
function applyExceptionAmounts(mongoFees, excRows) {
  const byCode = excRows.reduce((acc, r) => {
    (acc[r.FeeCode] ??= []).push(r);
    return acc;
  }, {});

  mongoFees.forEach(fee => {
    const excGrp = findGroup(fee, 'Exception Request');
    if (!excGrp) return;

    excGrp.fields.forEach(field => {
      const codes = Object.entries(feeCodeMap)
                          .filter(([, c]) => c === field.code)
                          .map(([k]) => k);
      const rows  = codes.flatMap(c => byCode[c] || []);
      if (!rows.length) return;

      /* ordena – numéricos ↑  depois alfanumérico ↑ */
      const nums  = rows.filter(r => !Number.isNaN(Number(r.Amount)))
                        .sort((a, b) => Number(a.Amount) - Number(b.Amount));
      const alpha = rows.filter(r => Number.isNaN(Number(r.Amount)))
                        .sort((a, b) => a.Amount.localeCompare(b.Amount));

      field.exceptionOptions = [...nums, ...alpha].map(r => ({
        value  : r.Amount,
        text   : Number.isNaN(Number(r.Amount))
                   ? (r.FreqDescription?.trim() || r.Amount)
                   : numberToCurrency(Number(r.Amount)),
        visible: true,
        retired: false
      }));

      field.defaultValue = '';
      field.labelValue   = '';
    });
  });
}

/* --------- patch p/ Client-Current (custody + equity/options) ---------- */
function patchClientCurrent(customerAccount, resultFees) {
  const invFee  = resultFees.find(f => f.feeType === 'Investment Account Fees');
  if (!invFee) return;

  const currGrp = findGroup(invFee, 'Client Current Fees');
  if (!currGrp) return;

  /* custody (code 6) */
  const custodyAcc = customerAccount.find(a => a.feeType === 6);
  if (custodyAcc) {
    const fld = currGrp.fields.find(f => f.code === 6);
    if (fld) {
      fld.defaultValue = custodyAcc.feeCode;
      fld.labelValue   = numberToCurrency(custodyAcc.feeAmount);
    }
  }

  /* equity / options (code 7) */
  const equityAcc  = customerAccount.find(a => a.bpsFeeTypeCode === 'E');
  const optionsAcc = customerAccount.find(a => a.bpsFeeTypeCode === 'O');
  const fld7       = currGrp.fields.find(f => f.code === 7);

  if (fld7 && equityAcc && optionsAcc) {
    fld7.defaultValue = '';   // usuário escolhe
    fld7.labelValue   =
      `Equity: ${equityAcc.feeAmount}; Option: ${optionsAcc.feeAmount}`;
  }
}

/* --------- no restante do arquivo mantenha igual --------- */
/* dentro de execute(), depois de montar result.fees */
patchClientCurrent(customerAccount, result.fees);
syncExceptionLabels(result.fees);
