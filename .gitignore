import { Fee } from '#src/models/entities/Fees.js';
import Result from '#features/shared/result.js';
import CustomerFees from '#src/models/CustomerFees.js';
import BankAccountFee from '#src/models/BankAccountFee.js';
import InvestimentAccountFee from '#src/models/InvestimentAccountFee.js';
import { FeeCase } from '#src/models/entities/FeeCase.js';
import { Field } from '#src/models/entities/Fields.js';
import {
  connectToFeeMgmtDb,
  executeStoreProcedure,
} from '#core/data/mssql/index.js';


export default class FeeGetByCifUseCase {
  // --------------------------------------------------

  async execute({ customerAccount }) {
    // 1.â€‘â€‘Â carrega modeloâ€‘padrÃ£o de taxas (Mongo)
    const fees = await this.#getFeeStandard([
      { feeType: 'Customer Fees' },
      { feeType: 'Bank Account Fees' },
      { feeType: 'Investment Account Fees' },
    ]);

    // 2.â€‘â€‘Â enriquece com dados do SQL
    const pkgData        = await this.#getPackageDataFromSQL(customerAccount[0].cifno);
    const currentPkgRows = await this.#getPackageDataFromCurrentSQL(customerAccount[0].cifno);

    // junta feeAmount / feeType em cada account
    customerAccount.forEach(acc => {
      const row = currentPkgRows.find(r => r.ddaNumber === acc.ddaNumber);
      if (row) Object.assign(acc, row);          // feeAmount, feeType, etc.
      Object.assign(acc, pkgData);               // branchCity, packageâ€¦
    });

    // 3.â€‘â€‘Â monta as estruturas jÃ¡ usadas pelo front
    const result = { fees: [] };

    const customer   = new CustomerFees       (fees, customerAccount);
    const bank       = new BankAccountFee     (fees, customerAccount);
    const investment = new InvestimentAccountFee(
                          fees, customerAccount, (await Field.find({ code: 7 }))[0]);

    [customer, bank, investment]
      .filter(f => f.fee && f.fee.feeGroups?.length)
      .forEach(f => result.fees.push(f.fee));

    const feesActives = await FeeCase.find({
      cif: customerAccount[0].cifno,
      status: { $nin: ['DONE', 'REJECTED'] },
      caseNumber: { $exists: true },
    });

    result.feesActives = feesActives.map(x => ({
      caseNumber: x.caseNumber,
      id:         x.id,
    }));

    // accounts detalhados para o Conductor
    result.accounts = customerAccount.map(acc => ({
      cifno:               acc.cifno,
      ddaNumber:           acc.ddaNumber,
      branchCity:          acc.branchCity,
      branchState:         acc.branchState,
      branchType:          acc.branchType,
      defaultPackageType:  acc.defaultPackageType,
      feePackage:          acc.feePackage,
      defaultFeePackageId: acc.defaultFeePackageId,
      defaultFeePackage:   acc.defaultFeePackage,
      documentUrl:         this.#getDocumentUrl(acc.defaultFeePackageId),
    }));

    result.documentUrl = this.#getDocumentUrl(pkgData.defaultFeePackageId);

    return Result.ok(result);
  }


  async #getPackageDataFromSQL(cifno) {
    const conn = await connectToFeeMgmtDb();
    const [row] = await executeStoreProcedure(conn, 'sp_get_fees_byCIF', { cifno });
    if (!row) return {};

    return {
      defaultFeePackageId: row['Default Fee Package Id'] ?? null,
      branchCity:          row['Branch City']?.trim()      || '',
      branchState:         row['Branch State']?.trim()     || '',
      branchType:          row['Branch Type']?.trim()      || '',
      defaultPackageType:  row['Default Package Type']?.trim() || '',
      feePackage:          row['Default Fee Package']?.trim()  || '',
    };
  }

  async #getPackageDataFromCurrentSQL(cifno) {
    const conn = await connectToFeeMgmtDb();
    const rows = await executeStoreProcedure(conn, 'sp_GetConductorFees', { CIF: cifno });
    if (!rows?.length) return [];

    return rows.map(r => ({
      cifno:            r.CIFNO?.trim(),
      ddaNumber:        String(r.DDANumber).trim(),
      feeType:          this.#sqlToFeeType(r),              // ðŸ‘ˆ conversÃ£o aqui
      feeDescription:   r.FeeDescription?.trim() || '',
      feeCode:          r.FeeCode?.trim()        || '',
      bpsFeeTypeCode:   r.BPSFeeTypeCode?.trim() || '',
      feeAmount:        Number(r.FeeAmount),
      source:           r.Source?.trim()         || '',
      entity:           r.Entity?.trim()         || '',
      isFeesStandard:   r.IsFeesStandard?.trim() || '',
      feeGroup:         (r.FeeType >= 5 ? 3 : r.FeeType >= 3 ? 2 : 1), // regra simples
    }));
  }

  #sqlToFeeType({ FeeCode, BPSFeeTypeCode }) {
    const byFeeCode = {
      JH001: 1,
      JH002: 2,
      JH010: 3,
      JH009: 4,
    };
    const byBpsCode = {
      S: 5,
      C: 6,
      E: 7,
      O: 7,
    };
    if (FeeCode && byFeeCode[FeeCode]) return byFeeCode[FeeCode];
    if (BPSFeeTypeCode && byBpsCode[BPSFeeTypeCode]) return byBpsCode[BPSFeeTypeCode];
    return 0;
  }

  #getDocumentUrl(feePackageId) {
    const urls = global.environment.scheduleUrls || {};
    const key  = ({ 1: 'intlPB3', 2: 'uSPBIndividual3', 3: 'uSPBCorporation3' })[feePackageId];
    return key ? urls[key] || '' : '';
  }

  // --------------------------------------------------
  // Mongo helper

  async #getFeeStandard(filter) {
    const feeResult = [];
    for await (const fee of Fee.find({ $or: filter }).select({
      feeType: 1,
      feeGroups: { name: 1, fields: 1, code: 1 },
    })) {
      feeResult.push(fee.toObject());
    }
    return feeResult;
  }
}
