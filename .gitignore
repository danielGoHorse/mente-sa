import http from 'node:http'
import url from 'node:url'
import { createHttpTerminator } from 'http-terminator'

import express from 'express'
import helmet from 'helmet'
import cors from 'cors'
import prometheusClient from 'prom-client'
import path from 'path'
import glob from 'glob'
import { promisify } from 'util'
// import { startConnectionWithSql } from '#core/data/index.js'
import { connectToFeeMgmtDb, executeStoreProcedure } from '#src/core/data/mssql/index.js'

import requestLogging from './middlewares/requestLogging.js'
import correlationId from './middlewares/correlationId.js'
import { createSwaggerRouter } from './swagger.js'

export default class ApiServer {
  #isReady = false
  #express = undefined

  #mountMiddlewares() {
    const maxRequestBodySize =
      global.environment.server.maxRequestBodySize || '100mb'

    this.#express.use(helmet({ contentSecurityPolicy: false }))
    this.#express.use(express.json({ limit: maxRequestBodySize }))
    this.#express.use(
      express.urlencoded({ limit: maxRequestBodySize, extended: true })
    )
    this.#express.use(cors())

    this.#express.use(requestLogging())
    this.#express.use(correlationId())
  }

  async #mountRoutes() {
    this.#mountHealthRoute()
    this.#mountMetricsRoute()
    await this.#autoMountFeatureRoutes()
  }

  #mountHealthRoute() {
    this.#express.get('/health', (_, res) => {
      if (!this.#isReady) {
        return res.status(503).send('Server shutting down')
      }

      res.send('Healthy')
    })
  }

  #mountMetricsRoute() {
    const register = new prometheusClient.Registry()
    prometheusClient.collectDefaultMetrics({ register })

    this.#express.get('/metrics', async (_, res) => {
      const metrics = await register.metrics()
      res.header('Content-Type', register.contentType)
      res.send(metrics)
    })
  }

  #mountSwaggerRoute(versionPath) {
    if (
      process.env.NODE_ENV !== 'Local' &&
      process.env.NODE_ENV !== 'Development'
    ) {
      return
    }

    const swaggerFiles = path.resolve(
      path.dirname(''),
      'src',
      'doc',
      'swagger',
      '**/*.yaml'
    )

    const routerSwagger = createSwaggerRouter(versionPath, [swaggerFiles])

    this.#express.use(versionPath, routerSwagger)
  }

  async #autoMountFeatureRoutes(versionPath = '/v1') {
    const featuresPath = path.resolve(
      path.dirname(''),
      'src',
      'features',
      '**/*Router.js'
    )

    const globAsync = promisify(glob)
    const routers = await globAsync(featuresPath, {
      windowsPathsNoEscape: true
    })

    this.#mountSwaggerRoute(versionPath)

    routers.forEach(async (router) => {
      const urlRouter = url.pathToFileURL(router)
      const routes = await import(urlRouter)
      this.#express.use(versionPath, routes.default)
    })
  }

  async #bootstrap() {
    global.logger.info('bootstraping application')

    this.#express = express()
    this.#express.set('port', global.environment.server.port)

    try{
      const connection = await connectToFeeMgmtDb();
      global.logger.info('Connected to SQL Server successfully.');
      
      const query = 'sp_get_feegroupinfo';
      const parameters = { group_id: 1 };
      const result = await executeStoreProcedure(connection, query, parameters);
      global.logger.info('Procedure Result:', result);

      global.sqlConnection = connection;
    }catch (err){
      global.logger.error('Failed to connect to SQL Server:', err.message);
    }

    this.#mountMiddlewares()
    await this.#mountRoutes()

    this.#isReady = true
  }

  async launch() {
    await this.#bootstrap()

    const serverError = (err) => {
      if (err.syscall !== 'listen') {
        throw err
      }

      throw err
    }

    const serverListening = () => {
      const addressInfo = server.address()
      global.logger.info(
        `Server started on ${addressInfo.address}:${global.environment.server.port}`
      )
    }

    const server = http.createServer(this.#express)
    const httpTerminator = createHttpTerminator({ server })

    server.on('error', serverError)
    server.on('listening', serverListening)
    server.listen(global.environment.server.port)

    const unhandledRejectionHandler = (err) => {
      const log = global.logger || console
      log.error('Unhandled Promise Rejection: err: ', err.message)
      log.error(err.stack)
    }

    const gracefulShutdownHandler = async () => {
      global.logger.info('Server received shutdown signal')
      this.#isReady = false

      global.logger.info('Waiting for open connections to be finished')
      await httpTerminator.terminate()

      global.logger.info('Server is closed')
      process.exit(0)
    }

    process.on('unhandledRejection', unhandledRejectionHandler)
    process.on('SIGINT', gracefulShutdownHandler)
    process.on('SIGTERM', gracefulShutdownHandler)
  }
}



[18:56:48.659] INFO (22028): Starting configuration for env: Local
[18:56:48.660] INFO (22028): Loading env using file H:\Documents\fee-management-backend\.env
[18:56:48.672] INFO (22028): bootstraping application
[18:56:48.677] ERROR (22028): Failed to connect to SQL Server:
[18:56:49.015] INFO (22028): Server started on :::3333

