const rawCustomerAccounts = customerData?.customerAccount || []; 

const feeTypeMap = {
  1: "Customer Fees",
  2: "Bank Account Fees",
  3: "Investment Account Fees"
};

// Log dos valores antes do filtro
console.log("Raw Customer Accounts:", rawCustomerAccounts);

const filteredCustomerAccounts = rawCustomerAccounts.filter(fee => {
  const feeTypeString = feeTypeMap[fee.feeType] || ""; // Converte número para string correspondente
  console.log(`Checking feeType after mapping: ${feeTypeString}`); // Debug
  return ["Customer Fees", "Bank Account Fees", "Investment Account Fees"].includes(feeTypeString);
});

// Log para ver se algum dado foi filtrado
console.log("Filtered Customer Accounts:", filteredCustomerAccounts);

const formattedFees = filteredCustomerAccounts.map(fee => ({
  feeGroups: [{
    name: fee.feeGroup === 1 ? "Client Current Fees" : "Standard Fees",
    visible: true,
    kycMailingStatus: fee.kycMailingStatus || null,
    code: fee.feeCode,
    accountNumber: fee.ddaNumber || '',
    cif: fee.cifno,
    id: '',
    fields: [{
      hasChanged: false,
      code: fee.feeCode, // Ajustado para referenciar corretamente o código da taxa
      name: formatCamelCaseToTitle(fee.feeDescription),
      defaultValue: fee.feeAmount?.toString() || '',
      isStandard: fee.isFeesStandard === "Yes",
      isException: fee.isFeesStandard === "No",
      isCurrentClient: false,
      labelValue: fee.feeAmount ? `$${fee.feeAmount.toFixed(2)}` : '',
      tooltip: fee.source ? `Source: ${fee.source}` : '',
      exceptionOptions: [],
      createdAt: timestamp,
      updatedAt: timestamp,
      id: fee.ddaNumber.toString()
    }]
  }],
  feeType: feeTypeString, // Agora, feeType é a string correta
  id: '',
}));

console.log("Final formattedFees:", formattedFees);
