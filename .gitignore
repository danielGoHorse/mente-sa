import { FeeGroup } from './entities/FeeGroups.js';
import numberToCurrency from '../core/helpers/currency.js';

export default class InvestmentAccountFee {
  #feeName = 'Investment Account Fees';
  #investiment = {};
  #accounts = [];
  #accountsDDA = [];
  #allExceptions = new Set();

  constructor(fees, accounts, equityField) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }
    // Seleciona os fees cujo FeeType seja "Investment Account Fees"
    this.#investiment = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (!this.#investiment || !Array.isArray(this.#investiment.feeGroups)) {
      throw new Error('Investment Account Fees or feeGroups are undefined');
    }
    if (!accounts || !Array.isArray(accounts) || accounts.length === 0) {
      throw new Error('Accounts is empty or undefined');
    }

    // Filtra as contas cujo feeType mapeado seja 3 (Investment)
    this.#accounts = accounts.filter((x) => x.feeType === 3);
    if (this.#accounts.length < 1) {
      throw new Error('No accounts matched with Investment Account Fees feeType');
    }

    // Para cada conta, criamos dois itens em accountsDDA com os códigos 5 e 7 (para os dois grupos de Investment)
    this.#accounts.forEach((acc) => {
      if (acc.ddaNumber) {
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 5,
          entity: acc.entity || null,
        });
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 7,
          entity: acc.entity || null,
        });
      }
    });
    // Deduplica os itens com base na chave "number-code"
    this.#accountsDDA = Array.from(
      new Map(this.#accountsDDA.map(item => [`${item.number}-${item.code}`, item])).values()
    );

    // Cria grupos (feeGroups) para cada conta única
    this.#addMultiplesAccount(this.#accounts[0].cifno);
    // Atualiza os valores (labelValue) de cada fee, conforme os dados do cliente e possíveis exceções
    this.#addCurrentClientValue(equityField);
  }

  get fee() {
    return this.#investiment;
  }

  /**
   * Função auxiliar para deduplicar os fields com base no código do fee.
   */
  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  /**
   * Para cada conta (representada em accountsDDA), cria um novo FeeGroup a partir dos templates
   * existentes em this.#investiment.feeGroups. Cada novo grupo terá o número da conta atribuído.
   */
  #addMultiplesAccount(cif) {
    const feeGroupTemplates = this.#investiment.feeGroups;
    const newFeeGroups = [];
    for (const account of this.#accountsDDA) {
      const accountNumber = account.number.toString();
      for (const template of feeGroupTemplates) {
        // Clona os fields para evitar referências compartilhadas
        let clonedFields = template.fields.map((field) => ({
          ...field,
          exceptionOptions: field.exceptionOptions
            ? field.exceptionOptions.map((opt) => ({ ...opt }))
            : []
        }));
        // Deduplica os fields com base no fee code
        clonedFields = this.#deduplicateFields(clonedFields);
        const newFeeGroup = new FeeGroup({
          name: template.name,
          fields: clonedFields,
          cif,
          accountNumber,
          visible: template.visible,
          code: template.code
        });
        newFeeGroups.push(newFeeGroup);
      }
    }
    this.#investiment.feeGroups = newFeeGroups;
  }

  /**
   * Atualiza os valores de cada fee (labelValue) para os grupos de Investment.
   * Para fields com código 5, usa o valor recebido do banco (texto) sem conversão.
   * Para os demais (por exemplo, código 7), converte o defaultValue para número e formata como moeda.
   */
  #addCurrentClientValue(equityField) {
    const exceptionsOptions = Array.from(this.#allExceptions);
    for (const feeGroup of this.#investiment.feeGroups) {
      feeGroup.cif = this.#accounts[0]?.cifno || null;
      for (const field of feeGroup.fields) {
        if (field.isException) {
          // Se for field de exceção, tenta copiar o labelValue do grupo anterior
          // (a lógica pode ser ajustada conforme necessidade)
          field.labelValue = field.labelValue || '';
        } else {
          // Para cada conta, se o número da conta do grupo bater com o ddaNumber da conta
          for (const account of this.#accounts) {
            if (
              feeGroup.accountNumber.toString() === account.ddaNumber.toString()
            ) {
              if (field.code === 5) {
                // Para fields com código 5, o defaultValue já contém o texto a ser exibido
                field.labelValue = field.defaultValue;
              } else {
                if (field.isCurrentClient) {
                  field.defaultValue = account.feeCode?.toString() || '';
                }
                const numValue = parseFloat(field.defaultValue);
                field.labelValue =
                  !isNaN(numValue) ? "$" + numValue.toFixed(2) : field.defaultValue;
              }
            }
          }
        }
      }
    }
    this.#clearMemory();
  }

  #clearMemory() {
    this.#accounts = [];
    this.#accountsDDA = [];
    this.#allExceptions = new Set();
  }
}
