function applyExceptionAmounts(mongoFees, excRows) {
  const byCode = excRows.reduce((acc, r) => {
    (acc[r.FeeCode] ??= []).push(r);
    return acc;
  }, {});

  function mergeEquityOption(rows) {
    const bucket = {};
    for (const r of rows) {
      const code = r.Amount;
      (bucket[code] ??= { eq: null, op: null });
      if (r.BPSFeeTypeCode === 'E') bucket[code].eq = r;
      if (r.BPSFeeTypeCode === 'O') bucket[code].op = r;
    }

    return Object.keys(bucket)
      .sort((a, b) => a.localeCompare(b))
      .map(code => {
        const { eq, op } = bucket[code];
        return {
          value: code,
          text: `${code} - Equity: ${eq?.FreqDescription || '-'}; Option: ${op?.FreqDescription || '-'}`,
          visible: true,
          retired: false,
        };
      });
  }

  mongoFees.forEach(fee => {
    const excGrp = findGroup(fee, 'Exception Request');
    if (!excGrp) return;

    excGrp.fields.forEach(field => {
      const codes = Object.entries(feeCodeMap)
                          .filter(([, c]) => c === field.code)
                          .map(([k]) => k);
      const rows = codes.flatMap(c => byCode[c] || []);
      if (!rows.length) return;

      if (field.code === 7) {
        field.exceptionOptions = mergeEquityOption(rows);
      } else {
        const nums = rows.filter(r => !Number.isNaN(Number(r.Amount)))
                         .sort((a, b) => Number(a.Amount) - Number(b.Amount));
        const alpha = rows.filter(r => Number.isNaN(Number(r.Amount)))
                          .sort((a, b) => a.Amount.localeCompare(b.Amount));
        field.exceptionOptions = [...nums, ...alpha].map(r => ({
          value: r.Amount,
          text: r.FreqDescription ? `${r.Amount} - ${r.FreqDescription}` : r.Amount,
          visible: true,
          retired: false,
        }));
      }

      field.defaultValue = '';
      field.labelValue = '';
    });
  });
}
