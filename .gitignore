useEffect(() => {
  async function hydrateDocs() {
    if (!data?.documents?.content?.length) {
      console.log("hydrateDocs: nada no data.documents");
      return;
    }

    if (documentList.length) {
      console.log("hydrateDocs: já tem docs no store, não rehidrato");
      return;
    }

    const paths: string[] = data.documents.content;
    console.log("hydrateDocs: paths recebidos do back =>", paths);

    // Se o endpoint de link assinado estiver falhando, faça try/catch
    async function getLinks(serverPath: string) {
      try {
        const res = await api.get("/v1/file/link", {
          params: { application: "conductor-client", path: serverPath },
        });
        const { url, urlPreview } = res.data.data;
        return { url, urlPreview };
      } catch (e) {
        console.error("Erro pegando link pra", serverPath, e);
        // fallback sem URL assinada
        return { url: undefined, urlPreview: undefined };
      }
    }

    const docs: UploadedDocument[] = await Promise.all(
      paths.map(async (p) => {
        const [uuid, ...rest] = p.split("/");
        const name = rest.join("/");
        const { url, urlPreview } = await getLinks(p);

        return {
          serverPath: p,
          serverUrlSigned: url,
          documentURLPreview: urlPreview,
          documentName: name,
          documentUUID: uuid,
          createdAt: data.createdAt ?? new Date().toISOString(),
          uploadedBy: { fullName: data.createdBy, userId: data.createdBy },
          documentStatus: "uploaded",
        };
      })
    );

    console.log("hydrateDocs: docs montados =>", docs);
    setDocumentList(docs);
  }

  hydrateDocs();
}, [data, documentList.length, setDocumentList]);
