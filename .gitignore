/* eslint-disable no-console */
import { Fee } from '#src/models/entities/Fees.js';
import Result from '#features/shared/result.js';
import CustomerFees from '#src/models/CustomerFees.js';
import BankAccountFee from '#src/models/BankAccountFee.js';
import InvestimentAccountFee from '#src/models/InvestimentAccountFee.js';
import { FeeCase } from '#src/models/entities/FeeCase.js';
import { Field } from '#src/models/entities/Fields.js';
import numberToCurrency from '#core/helpers/currency.js';
import {
  connectToFeeMgmtDb,
  executeStoreProcedure,
} from '#core/data/mssql/index.js';

/* ───────────── helpers SQL ───────────── */

async function getPackageData(cifno) {
  const conn = await connectToFeeMgmtDb();
  const [row] = await executeStoreProcedure(conn, 'sp_get_fees_byCIF', { cifno });
  if (!row) return {};

  return {
    defaultFeePackageId: row['Default Fee Package Id'] ?? null,
    branchCity: row['Branch City']?.trim() || '',
    branchState: row['Branch State']?.trim() || '',
    branchType: row['Branch Type']?.trim() || '',
    defaultPackageType: row['Default Package Type']?.trim() || '',
    feePackage: row['Default Fee Package']?.trim() || '',
  };
}

async function getStandardFees(packageId) {
  const conn = await connectToFeeMgmtDb();
  const rows = await executeStoreProcedure(
    conn, 'sp_get_standard_fees_bypackage',
    { FeePackageId: packageId },
  );
  console.log('STD-rows', rows?.length);
  return rows ?? [];
}

async function getExceptionFees(packageId) {
  const conn = await connectToFeeMgmtDb();
  const rows = await executeStoreProcedure(
    conn, 'sp_get_exception_fees_bypackage',
    { FeePackageId: packageId },
  );
  console.log('EXC-rows', rows?.length);
  return rows ?? [];
}

function getDocumentUrl(id) {
  const urls = global.environment.scheduleUrls || {};
  const key = ({ 1: 'intlPB3', 2: 'uSPBIndividual3', 3: 'uSPBCorporation3' })[id];
  return key ? urls[key] || '' : '';
}

/* ───────────── helpers Mongo / modelo ───────────── */

async function getFeeStandard(filter) {
  return Fee.find({ $or: filter })
    .select({ feeType: 1, feeGroups: { name: 1, fields: 1, code: 1 } })
    .lean();
}

function findGroup(fee, name) {
  return fee?.feeGroups?.find(g => g.name === name);
}

/* mapeamento FeeCode → field.code */
const feeCodeMap = {
  JH001: 1, JH002: 2, JH010: 3, JH008: 4,
  BPS002: 6, BPS003: 5, BPS004: 7, BPS005: 7,
};

/* ───────────── Standard Fees ───────────── */
function applyStandardAmounts(mongoFees, stdRows) {
  mongoFees.forEach(fee => {
    const stdGrp = findGroup(fee, 'Standard Fees');
    if (!stdGrp) return;

    stdGrp.fields.forEach(field => {
      const row = stdRows.find(r => Number(r.FeeType) === field.code);
      if (!row) return;

      const num = Number(row.FeeAmount);

      if (!Number.isNaN(num)) {
        field.defaultValue = num.toString();
        field.labelValue = numberToCurrency(num);
      } else {
        field.defaultValue = row.FeeAmount;
        field.labelValue = row.FrequencyDescription?.trim() || row.FeeAmount;
      }

      field.tooltip = row.FrequencyDescription?.trim() || '';
    });
  });
}

/* ───────────── Exception Fees ───────────── */
// function applyExceptionAmounts(mongoFees, excRows) {
//   const byCode = excRows.reduce((acc, r) => {
//     (acc[r.FeeCode] ??= []).push(r);
//     return acc;
//   }, {});

//   mongoFees.forEach(fee => {
//     const excGrp = findGroup(fee, 'Exception Request');
//     if (!excGrp) return;

//     excGrp.fields.forEach(field => {
//       const codes = Object.entries(feeCodeMap)
//                           .filter(([, c]) => c === field.code)
//                           .map(([k]) => k);
//       const rows  = codes.flatMap(c => byCode[c] || []);
//       if (!rows.length) return;

//       const nums  = rows.filter(r => !Number.isNaN(Number(r.Amount)))
//                         .sort((a, b) => Number(a.Amount) - Number(b.Amount));
//       const alpha = rows.filter(r => Number.isNaN(Number(r.Amount)))
//                         .sort((a, b) => a.Amount.localeCompare(b.Amount));

//       field.exceptionOptions = [...nums, ...alpha].map(r => ({
//         value  : r.Amount,
//         text   : Number.isNaN(Number(r.Amount))
//                    ? (r.FreqDescription?.trim() || r.Amount)
//                    : numberToCurrency(Number(r.Amount)),
//         visible: true,
//         retired: false,
//       }));

//       field.defaultValue = '';
//       field.labelValue   = '';
//     });
//   });
// }

function applyExceptionAmounts(mongoFees, excRows) {
  const byCode = excRows.reduce((acc, r) => {
    (acc[r.FeeCode] ??= []).push(r);
    return acc;
  }, {});

  /* helper p/ Equity + Option  ───────────── */
  function mergeEquityOption(rows) {
    const byId = {};
    rows.forEach(r => {
      const id = r.FeeParameterOptionId;
      (byId[id] ??= { E: null, O: null });
      if (r.BPSFeeTypeCode === 'E') byId[id].E = r;
      if (r.BPSFeeTypeCode === 'O') byId[id].O = r;
    });
    return Object.values(byId).map(({ E, O }) => ({
      value: (E?.Amount || O?.Amount)?.toString(),
      text: `Equity: ${E?.FreqDescription ?? '-'}; Option: ${O?.FreqDescription ?? '-'}`,
      visible: true, retired: false
    }));
  }

  mongoFees.forEach(fee => {
    const excGrp = findGroup(fee, 'Exception Request');
    if (!excGrp) return;

    excGrp.fields.forEach(field => {
      const code = Object.entries(feeCodeMap)
        .find(([, c]) => c === field.code)?.[0];
      let rows = code ? byCode[code] : null;
      if (!rows?.length) return;

      /* ---------- Equity / Option (code 7) ---------- */
      if (field.code === 7) {
        field.exceptionOptions = mergeEquityOption(rows);
      } else {
        /* ordena numéricos primeiro */
        const nums = rows.filter(r => !Number.isNaN(Number(r.Amount)))
          .sort((a, b) => Number(a.Amount) - Number(b.Amount));
        const alpha = rows.filter(r => Number.isNaN(Number(r.Amount)))
          .sort((a, b) => a.Amount.localeCompare(b.Amount));
        field.exceptionOptions = [...nums, ...alpha].map(r => ({
          value: r.Amount.toString(),
          text: Number.isNaN(Number(r.Amount))
            ? (r.FreqDescription?.trim() || r.Amount)
            : numberToCurrency(Number(r.Amount)),
          visible: true,
          retired: false
        }));
      }

      field.defaultValue = '';
      field.labelValue = '';
    });
  });
}

/* ───────────── Ajuste Client-Current (custody & equity/options) ───────────── */
function patchClientCurrent(customerAccount, feesArr) {
  const invFee = feesArr.find(f => f.feeType === 'Investment Account Fees');
  if (!invFee) return;

  const currGrp = findGroup(invFee, 'Client Current Fees');
  if (!currGrp) return;

  /* custody (code 6) ---------------------------------------------------- */
  const custodyAcc = customerAccount.find(a => a.feeType === 6);
  if (custodyAcc) {
    const fld = currGrp.fields.find(f => f.code === 6);
    if (fld) {
      fld.defaultValue = custodyAcc.feeCode;
      fld.labelValue = numberToCurrency(custodyAcc.feeAmount);
    }
  }

  /* equity (E) & options (O) – code 7 ----------------------------------- */
  const equityAcc = customerAccount.find(a => a.bpsFeeTypeCode === 'E');
  const optionsAcc = customerAccount.find(a => a.bpsFeeTypeCode === 'O');
  const fld7 = currGrp.fields.find(f => f.code === 7);

  if (fld7 && equityAcc && optionsAcc) {
    fld7.defaultValue = '';
    fld7.labelValue =
      `Equity: ${equityAcc.feeAmount}; Option: ${optionsAcc.feeAmount}`;
  }
}

function syncExceptionLabels(feesArr) {
  feesArr.forEach(fee => {
    const exc = findGroup(fee, 'Exception Request');
    if (!exc) return;
    exc.fields.forEach(f => {
      const val = f.defaultValue;
      f.labelValue = val ? numberToCurrency(Number(val)) : '';
    });
  });
}

export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    const fees = await getFeeStandard([
      { feeType: 'Customer Fees' },
      { feeType: 'Bank Account Fees' },
      { feeType: 'Investment Account Fees' },
    ]);

    if (customerAccount || customerAccount.length === 0) {
      customerAccount = [
        {
          cifno           : 'NAA0010',
          ddaNumber       : 17226444,
          bpsAcctNumber   : '',           // DDA “puro”
          feeType         : 1,
          feeDescription  : 'AccountMaintenance',
          feeCode         : 'JH001',
          bpsFeeTypeCode  : '',
          feeAmount       : 1501,
          source          : 'JHA',
          entity          : 'SNB/284',
          isFeesStandard  : 'Yes',
          kycMailingStatus: null,
          feeGroup        : 1,
        },
        {
          cifno           : 'NAA0010',
          ddaNumber       : 17226444,
          bpsAcctNumber   : '',
          feeType         : 2,
          feeDescription  : 'HoldMail',
          feeCode         : 'JH002',
          bpsFeeTypeCode  : '',
          feeAmount       : 600,
          source          : 'JHA',
          entity          : 'SNB/284',
          isFeesStandard  : 'Yes',
          kycMailingStatus: null,
          feeGroup        : 1,
        },
        {
          cifno          : 'NAA0010',
          ddaNumber      : 17226444,
          bpsAcctNumber  : '',
          feeType        : 4,
          feeDescription : 'USD/FXOutgoingWire',
          feeCode        : 'JH008',
          bpsFeeTypeCode : '',
          feeAmount      : 20,
          source         : 'JHA',
          entity         : 'SNB/284',
          isFeesStandard : 'No',
          feeGroup       : 2,
        },
        {
          cifno          : 'NAA0010',
          ddaNumber      : 17226444,
          bpsAcctNumber  : '20103939',
          feeType        : 5,
          feeDescription : 'SSLMaintenanace',
          feeCode        : 'BPS003',
          bpsFeeTypeCode : 'S',
          feeAmount      : 0,
          source         : 'BPS',
          entity         : 'SSL/189',
          isFeesStandard : 'No',
          feeGroup       : 3,
        },
        {
          cifno          : 'NAA0010',
          ddaNumber      : 17226444,
          bpsAcctNumber  : '20002089',
          feeType        : 6,
          feeDescription : 'SafekeepingCustody',
          feeCode        : 'BPS002',
          bpsFeeTypeCode : 'C',
          feeAmount      : 375,
          source         : 'BPS',
          entity         : 'SNB/284',
          isFeesStandard : 'Yes',
          kycMailingStatus: null,
          feeGroup       : 3,
        },
        {
          cifno          : 'NAA0010',
          ddaNumber      : 17226444,
          bpsAcctNumber  : '20103939',
          feeType        : 7,
          feeDescription : 'EquityCommissions',
          feeCode        : 'BPS004',
          bpsFeeTypeCode : 'E',
          feeAmount      : 0,
          source         : 'BPS',
          entity         : 'SSL/189',
          isFeesStandard : 'Yes',
          feeGroup       : 3,
        },
        {
          cifno          : 'NAA0010',
          ddaNumber      : 17226444,
          bpsAcctNumber  : '20103939',
          feeType        : 7,
          feeDescription : 'OptionsCommissions',
          feeCode        : 'BPS005',
          bpsFeeTypeCode : 'O',
          feeAmount      : 0,
          source         : 'BPS',
          entity         : 'SSL/189',
          isFeesStandard : 'Yes',
          feeGroup       : 3,
        },
      ];
    }

    console.log('CUSTOMER',customerAccount)
    const pkgData = await getPackageData(customerAccount[0].cifno);
    const packageId = pkgData.defaultFeePackageId;

    const stdRows = await getStandardFees(packageId);
    const excRows = await getExceptionFees(packageId);

    applyStandardAmounts(fees, stdRows);
    applyExceptionAmounts(fees, excRows);

    customerAccount.forEach(acc => Object.assign(acc, pkgData));

    const result = { fees: [] };
    const [customer, bank, investment] = [
      new CustomerFees(fees, customerAccount),
      new BankAccountFee(fees, customerAccount),
      new InvestimentAccountFee(
        fees, customerAccount, await Field.findOne({ code: 7 }),
      ),
    ];
    [customer, bank, investment]
      .filter(f => f.fee && f.fee.feeGroups?.length)
      .forEach(f => result.fees.push(f.fee));

    const actives = await FeeCase.find({
      cif: customerAccount[0].cifno,
      status: { $nin: ['DONE', 'REJECTED'] },
      caseNumber: { $exists: true },
    });
    result.feesActives = actives.map(({ caseNumber, id }) => ({ caseNumber, id }));

    const docUrl = getDocumentUrl(packageId);
    result.accounts = customerAccount.map(acc => ({
      cifno: acc.cifno,
      ddaNumber: acc.ddaNumber,
      branchCity: acc.branchCity,
      branchState: acc.branchState,
      branchType: acc.branchType,
      defaultPackageType: acc.defaultPackageType,
      feePackage: acc.feePackage,
      defaultFeePackageId: acc.defaultFeePackageId,
      defaultFeePackage: acc.defaultFeePackage,
      documentUrl: docUrl,
      feeAmount: acc.feeAmount,
      exceptionAmount: acc.exceptionAmount ?? null,
    }));
    result.documentUrl = docUrl;

    patchClientCurrent(customerAccount, result.fees);
    syncExceptionLabels(result.fees);

    return Result.ok(result);
  }
}
