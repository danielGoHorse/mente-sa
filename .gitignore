import { FeeGroup } from './entities/FeeGroups.js';
import numberToCurrency from '../core/helpers/currency.js';

export default class CustomerFees {
  #feeName = 'Customer Fees';
  #customer = {};
  #accounts = [];

  constructor(fees, accounts) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }
    // Seleciona os dados do fee do tipo Customer Fees
    this.#customer = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (!this.#customer || !Array.isArray(this.#customer.feeGroups)) {
      throw new Error('Customer Fees or feeGroups are undefined');
    }
    if (!accounts || !Array.isArray(accounts) || accounts.length === 0) {
      throw new Error('Accounts is empty or undefined');
    }
    // Para fees de cliente, geralmente há apenas uma conta
    this.#accounts = [accounts[0]];

    this.#addMultiplesAccount(this.#accounts[0].cifno);
    this.#addCurrentClientValue();
  }

  /**
   * Função auxiliar para deduplicar os campos (fields) com base no fee code.
   *
   * @param {Array} fields - Array de fields a serem deduplicados.
   * @returns {Array} - Array de fields sem duplicação.
   */
  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  /**
   * Gera os feeGroups para a conta, clonando os grupos originais
   * e atribuindo o número da conta (accountNumber). Como para Customer Fees
   * normalmente há apenas uma conta, não há replicação.
   *
   * @param {string} cif - O CIF do cliente.
   */
  #addMultiplesAccount(cif) {
    const feeGroupTemplates = this.#customer.feeGroups;
    const newFeeGroups = [];

    for (const template of feeGroupTemplates) {
      // Clona os fields para evitar referências compartilhadas
      let clonedFields = template.fields.map((field) => ({
        ...field,
        exceptionOptions: field.exceptionOptions
          ? field.exceptionOptions.map((opt) => ({ ...opt }))
          : []
      }));

      // Deduplica os fields com base no fee code
      clonedFields = this.#deduplicateFields(clonedFields);

      const newFeeGroup = new FeeGroup({
        name: template.name,
        fields: clonedFields,
        cif,
        accountNumber: this.#accounts[0].ddaNumber.toString(),
        visible: template.visible,
        code: template.code
      });
      newFeeGroups.push(newFeeGroup);
    }

    this.#customer.feeGroups = newFeeGroups;
  }

  /**
   * Atualiza os valores dos fees para cada grupo, definindo o labelValue com base no valor.
   * Para Customer Fees, se o campo defaultValue já estiver definido (vindo do banco),
   * ele não é sobrescrito, garantindo que o valor "25.00" seja mantido.
   */
  #addCurrentClientValue() {
    // Para cada feeGroup, atualiza o labelValue usando o defaultValue já definido
    for (const feeGroup of this.#customer.feeGroups) {
      for (const field of feeGroup.fields) {
        // Se o field não for de exception, usamos o defaultValue que já vem do banco.
        // Caso o field seja de exception, podemos atualizar o labelValue também.
        field.labelValue = numberToCurrency(field.defaultValue);
      }
    }
  }

  get fee() {
    return this.#customer;
  }
}
