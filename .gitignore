import { FeeGroup } from './entities/FeeGroups.js';
import numberToCurrency from '../core/helpers/currency.js';

export default class BankAccountFee {
  #feeName = 'Bank Account Fees';
  #bank = {};
  #accounts = [];
  #accountsDDA = [];

  constructor(fees, accounts) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }

    // Seleciona os dados do fee do tipo Bank Account Fees
    this.#bank = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (!this.#bank || !Array.isArray(this.#bank.feeGroups)) {
      throw new Error('Bank Account Fees or feeGroups are undefined');
    }

    if (!accounts || !Array.isArray(accounts) || accounts.length === 0) {
      throw new Error('Accounts is empty or undefined');
    }

    const feeGroupCode = this.#bank.feeGroups[0].code;
    // Filtra as contas que pertencem ao grupo e que são do tipo Bank Account (feeType === 2)
    const accountsFiltered = accounts.filter(
      (x) => x.feeGroup === feeGroupCode && x.feeType === 2
    );
    this.#accounts = Array.from(
      new Map(accountsFiltered.map((a) => [a.ddaNumber, a])).values()
    );
    // Obtém os números de conta de forma única (já em string)
    this.#accountsDDA = this.#accounts.map((a) => a.ddaNumber.toString());

    if (this.#accounts.length === 0) {
      throw new Error('No accounts matched with Bank Account Fees feeGroup');
    }

    // Cria os feeGroups para cada conta única
    this.#addMultiplesAccount(this.#accounts[0].cifno);
    // Atualiza os valores dos fees para cada grupo
    this.#addCurrentClientValue();
  }

  /**
   * Deduplica os campos (fields) com base no fee code.
   * @param {Array} fields - Array de fields a serem deduplicados.
   * @returns {Array} - Array de fields sem duplicação.
   */
  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  /**
   * Para cada conta única, gera novos feeGroups a partir dos templates,
   * atribuindo o número da conta (accountNumber) e, se for "Client Current Fees",
   * marca os campos com isCurrentClient.
   * @param {string} cif - O CIF da conta.
   */
  #addMultiplesAccount(cif) {
    if (!this.#accounts || this.#accounts.length < 1) {
      this.#bank = {};
      return;
    }

    const feeGroupTemplates = this.#bank.feeGroups;
    const newFeeGroups = [];

    for (const account of this.#accounts) {
      const accountNumber = account.ddaNumber.toString();
      for (const template of feeGroupTemplates) {
        // Clona os fields para evitar referências compartilhadas
        let clonedFields = template.fields.map((field) => ({
          ...field,
          exceptionOptions: field.exceptionOptions
            ? field.exceptionOptions.map((opt) => ({ ...opt }))
            : []
        }));

        // Se o grupo for "Client Current Fees", marca os campos como current client
        if (template.name === 'Client Current Fees') {
          clonedFields = clonedFields.map(field => ({ ...field, isCurrentClient: true }));
        }

        // Deduplica os fields com base no fee code
        clonedFields = this.#deduplicateFields(clonedFields);

        const newFeeGroup = new FeeGroup({
          name: template.name,
          fields: clonedFields,
          cif,
          accountNumber,
          visible: template.visible,
          code: template.code
        });
        newFeeGroups.push(newFeeGroup);
      }
    }

    this.#bank.feeGroups = newFeeGroups;
  }

  /**
   * Atualiza os valores dos fees para cada grupo, formatando o defaultValue
   * e labelValue dos campos current client para terem duas casas decimais e "$".
   */
  #addCurrentClientValue() {
    for (const feeGroup of this.#bank.feeGroups) {
      feeGroup.cif = this.#accounts[0]?.cifno || null;
      for (const field of feeGroup.fields) {
        if (!field.isException) {
          if (field.isCurrentClient) {
            const numValue = parseFloat(field.defaultValue);
            field.defaultValue = !isNaN(numValue) ? numValue.toFixed(2) : field.defaultValue;
            field.labelValue = !isNaN(numValue) ? "$" + numValue.toFixed(2) : field.defaultValue;
          } else {
            const numValue = parseFloat(field.defaultValue);
            field.labelValue = !isNaN(numValue) ? "$" + numValue.toFixed(2) : field.defaultValue;
          }
        }
      }
    }
    this.#clearMemory();
  }

  get fee() {
    return this.#bank;
  }

  #clearMemory() {
    this.#accounts = [];
    this.#accountsDDA = [];
  }
}
