async #getFeesStructuredFromSQL(customerAccount) {
  const feesData = await this.#getFeesFromSQL(customerAccount[0].cifno);

  const feePackageId = feesData[0]?.['Default Fee Package Id'];
  if (!feePackageId) {
    throw new Error('Default Fee Package Id not found in feesData');
  }

  const documentUrl = this.#getDocumentUrl(feePackageId);

  // Monta a lista de contas
  const accounts = feesData.map((fee) => ({
    cifno: fee.CIFNO,
    ddaNumber: fee.ACCTNO,
    branchCity: fee['Branch City'],
    branchState: fee['Branch State'],
    branchType: fee['Branch Type'],
    defaultPackageType: fee['Default Package Type'],
    feePackage: fee['Default Fee Package']?.trim() || '',
    defaultFeePackageId: fee['Default Fee Package Id'] || '',
    feeType: this.#mapFeeType(fee.FeeType),
    feeGroup: 1,
    kycMailingStatus: fee.StandardException === 'Standard' ? 'Standard' : 'Hold Mail',
    documentUrl,
  }));

  // Agrupador principal
  const groupedFees = {};

  // Cria grupos iniciais (caso queira garantir que existam, mesmo sem dados)
  // FeeType => Nome do grupo
  const possibleFeeTypes = [
    'Customer Fees',
    'Bank Account Fees',
    'Investment Account Fees'
  ];

  for (const feeType of possibleFeeTypes) {
    if (!groupedFees[feeType]) {
      groupedFees[feeType] = {
        feeType,
        feeGroups: []
      };
    }
    // Se quiser garantir que todos os grupos existam (Standard Fees, Client Current Fees, Exceptions Request)
    // mesmo antes do loop:
    if (!groupedFees[feeType].feeGroups.find(g => g.name === 'Standard Fees')) {
      groupedFees[feeType].feeGroups.push({
        name: 'Standard Fees',
        code: 1,
        fields: []
      });
    }
    if (!groupedFees[feeType].feeGroups.find(g => g.name === 'Client Current Fees')) {
      groupedFees[feeType].feeGroups.push({
        name: 'Client Current Fees',
        code: 2,
        fields: []
      });
    }
    if (!groupedFees[feeType].feeGroups.find(g => g.name === 'Exceptions Request')) {
      groupedFees[feeType].feeGroups.push({
        name: 'Exceptions Request',
        code: 3,
        fields: []
      });
    }
  }

  // Monta grupos (Standard Fees e Client Current Fees) com base no retorno
  for (const fee of feesData) {
    const {
      FeeType,
      FeeDescription,
      FeeCode,
      FeeAmount,
      Frequency,
      DefaultFeeAmount,
      DefaultFrequency,
    } = fee;

    const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;

    if (
      (FeeType === 'Customer Fees' && ![1, 2].includes(mappedCode)) ||
      (FeeType === 'Bank Account Fees' && ![3, 4].includes(mappedCode)) ||
      (FeeType === 'Investment Account Fees' && ![5, 6, 7].includes(mappedCode)) ||
      excludedCodes.has(mappedCode)
    ) {
      continue;
    }

    // Garanta que o groupedFees[FeeType] exista
    if (!groupedFees[FeeType]) {
      groupedFees[FeeType] = {
        feeType: FeeType,
        feeGroups: []
      };
    }

    // Pega o grupo "Standard Fees"
    const standardGroup = groupedFees[FeeType].feeGroups.find(
      (group) => group.name === 'Standard Fees'
    );
    // Adiciona o field
    standardGroup.fields.push({
      code: mappedCode,
      name: FeeDescription,
      defaultValue: FeeAmount ? FeeAmount.toString() : '',
      tooltip: Frequency || '',
      isException: false
    });

    // Pega o grupo "Client Current Fees"
    const clientCurrentGroup = groupedFees[FeeType].feeGroups.find(
      (group) => group.name === 'Client Current Fees'
    );
    clientCurrentGroup.fields.push({
      code: mappedCode,
      name: FeeDescription,
      defaultValue: DefaultFeeAmount ? DefaultFeeAmount.toString() : '',
      tooltip: DefaultFrequency || '',
      isException: false
    });

    // OBS: Não estamos mexendo na parte "Exceptions Request" aqui ainda,
    // pois ela será tratada abaixo, usando o sp_get_exception_fees_bypackage
  }

  // Agora trata as Exceptions do DB para popular as exceptionOptions
  const exceptions = await this.#getExceptionFeesFromSQL(feePackageId);

  // Organiza exceptions por FeeType (caso precise)
  // Dependendo de como você retorna do stored procedure, talvez
  // seja necessário mapear o "FeeType" ou algo assim.
  // Supondo que sp_get_exception_fees_bypackage também retorne algo do tipo "FeeType"
  // Se não retornar, você terá que descobrir de outra forma qual FeeType é.
  // Aqui vou supor que ele retorna "FeeType" e "FeeCode".
  // Vamos mapear as exceptions por FeeType -> code -> array de exceptions
  const exceptionsByFeeTypeAndCode = {};
  for (const exc of exceptions) {
    // lembre de mapear exc para "FeeType" se existir
    const feeType = exc.FeeType; // Ex: "Customer Fees", "Bank Account Fees", etc
    if (!exceptionsByFeeTypeAndCode[feeType]) {
      exceptionsByFeeTypeAndCode[feeType] = {};
    }
    const code = exc.code; // já mapeado pelo dePara
    if (!exceptionsByFeeTypeAndCode[feeType][code]) {
      exceptionsByFeeTypeAndCode[feeType][code] = [];
    }
    exceptionsByFeeTypeAndCode[feeType][code].push(exc);
  }

  // Agora percorrer cada FeeType e inserir no grupo "Exceptions Request"
  for (const feeType of possibleFeeTypes) {
    const exceptionGroup = groupedFees[feeType]?.feeGroups.find(
      (group) => group.name === 'Exceptions Request'
    );
    if (!exceptionGroup) continue;

    // Precisamos descobrir quais "codes" existem nos grupos Standard/Client
    // ou mesmo codes "default" que você queira exibir. Nesse exemplo,
    // estou pegando todos que já foram criados nos outros grupos
    const existingCodes = new Set();
    const standardFields = groupedFees[feeType]?.feeGroups.find(g => g.name === 'Standard Fees')?.fields || [];
    const clientFields = groupedFees[feeType]?.feeGroups.find(g => g.name === 'Client Current Fees')?.fields || [];
    for (const f of standardFields) {
      existingCodes.add(f.code);
    }
    for (const f of clientFields) {
      existingCodes.add(f.code);
    }

    // Para cada code que já exista (ou se quiser expandir com codes fixos),
    // crie o field principal do Exceptions Request se não existir
    for (const code of existingCodes) {
      let exceptionField = exceptionGroup.fields.find((f) => f.code === code);
      if (!exceptionField) {
        // Cria esse field "vazio" (ou default) no Exceptions Request
        exceptionField = {
          code,
          name: '',         // pode popular com base no que já tem nos outros grupos
          defaultValue: '', // ou "0"
          tooltip: '',
          isException: true,
          exceptionOptions: []
        };
        exceptionGroup.fields.push(exceptionField);
      }
    }

    // Agora, popula de fato as exceptionOptions vindas do banco
    const codesExceptions = exceptionsByFeeTypeAndCode[feeType] || {};

    // codesExceptions é algo do tipo { 1: [exc1, exc2], 2: [exc3], ... }
    Object.entries(codesExceptions).forEach(([code, listExc]) => {
      const codeNumber = Number(code); 
      // Acha o field do Exceptions Request
      const exceptionField = exceptionGroup.fields.find((f) => f.code === codeNumber);
      // Se não existe, cria
      if (!exceptionField) {
        exceptionGroup.fields.push({
          code: codeNumber,
          name: listExc[0].name || '', 
          defaultValue: listExc[0].defaultValue || '0',
          tooltip: listExc[0].tooltip || '',
          isException: true,
          exceptionOptions: []
        });
      }
      const fieldRef = exceptionGroup.fields.find((f) => f.code === codeNumber);

      // Preenche as exceptionOptions no formato QA
      listExc.forEach((exc) => {
        // No seu DB: exc.FeeParameterOptionId -> parameterOptionId
        // exc.Amount -> value
        // Se quiser formatar, ex: text -> `$${parseFloat(exc.Amount).toFixed(2)}` etc
        const amountNumber = parseFloat(exc.defaultValue || '0');
        const option = {
          approvedByDoubleA: null,
          value: exc.defaultValue || '0', 
          text: `$${amountNumber.toFixed(2)}`,
          visible: true,
          retired: false,
          parameterOptionId: exc.parameterOptionId,
          // se precisar de _id, depende de como faz
          // "_id": <algumIdGeradoOuDoBanco>
        };
        fieldRef.exceptionOptions.push(option);
      });
    });
  }

  return { groupedFees: Object.values(groupedFees), accounts };
}
