# Specifies intentionally untracked files to ignore when using Git
# http://git-scm.com/docs/gitignore

*~
*.sw[mnpcod]
.tmp
*.tmp
*.tmp.*
UserInterfaceState.xcuserstate
$RECYCLE.BIN/

*.log
log.txt


/.sourcemaps
/.versions
/coverage

# Ionic
/.ionic
/www
/platforms
/plugins

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-project
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.history/*


# Miscellaneous
/.angular
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# System files
.DS_Store
Thumbs.db



import http from 'node:http'
import url from 'node:url'
import { createHttpTerminator } from 'http-terminator'

import express from 'express'
import helmet from 'helmet'
import cors from 'cors'
import prometheusClient from 'prom-client'
import path from 'path'
import glob from 'glob'
import { promisify } from 'util'
import { startConnectionWithMongoDb } from '#core/data/index.js'

import requestLogging from './middlewares/requestLogging.js'
import correlationId from './middlewares/correlationId.js'
import { createSwaggerRouter } from './swagger.js'

export default class ApiServer {
  #isReady = false
  #express = undefined

  #mountMiddlewares() {
    const maxRequestBodySize =
      global.environment.server.maxRequestBodySize || '100mb'

    this.#express.use(helmet({ contentSecurityPolicy: false }))
    this.#express.use(express.json({ limit: maxRequestBodySize }))
    this.#express.use(
      express.urlencoded({ limit: maxRequestBodySize, extended: true })
    )
    this.#express.use(cors())

    this.#express.use(requestLogging())
    this.#express.use(correlationId())
  }

  async #mountRoutes() {
    this.#mountHealthRoute()
    this.#mountMetricsRoute()
    await this.#autoMountFeatureRoutes()
  }

  #mountHealthRoute() {
    this.#express.get('/health', (_, res) => {
      if (!this.#isReady) {
        return res.status(503).send('Server shutting down')
      }

      res.send('Healthy')
    })
  }

  #mountMetricsRoute() {
    const register = new prometheusClient.Registry()
    prometheusClient.collectDefaultMetrics({ register })

    this.#express.get('/metrics', async (_, res) => {
      const metrics = await register.metrics()
      res.header('Content-Type', register.contentType)
      res.send(metrics)
    })
  }

  #mountSwaggerRoute(versionPath) {
    if (
      process.env.NODE_ENV !== 'Local' &&
      process.env.NODE_ENV !== 'Development'
    ) {
      return
    }

    const swaggerFiles = path.resolve(
      path.dirname(''),
      'src',
      'doc',
      'swagger',
      '**/*.yaml'
    )

    const routerSwagger = createSwaggerRouter(versionPath, [swaggerFiles])

    this.#express.use(versionPath, routerSwagger)
  }

  async #autoMountFeatureRoutes(versionPath = '/v1') {
    const featuresPath = path.resolve(
      path.dirname(''),
      'src',
      'features',
      '**/*Router.js'
    )

    const globAsync = promisify(glob)
    const routers = await globAsync(featuresPath, {
      windowsPathsNoEscape: true
    })

    this.#mountSwaggerRoute(versionPath)

    routers.forEach(async (router) => {
      const urlRouter = url.pathToFileURL(router)
      const routes = await import(urlRouter)
      this.#express.use(versionPath, routes.default)
    })
  }

  async #bootstrap() {
    global.logger.info('bootstraping application')

    this.#express = express()
    this.#express.set('port', global.environment.server.port)

    startConnectionWithMongoDb(global.environment.mongo)

    this.#mountMiddlewares()
    await this.#mountRoutes()

    this.#isReady = true
  }

  async launch() {
    await this.#bootstrap()

    const serverError = (err) => {
      if (err.syscall !== 'listen') {
        throw err
      }

      throw err
    }

    const serverListening = () => {
      const addressInfo = server.address()
      global.logger.info(
        `Server started on ${addressInfo.address}:${global.environment.server.port}`
      )
    }

    const server = http.createServer(this.#express)
    const httpTerminator = createHttpTerminator({ server })

    server.on('error', serverError)
    server.on('listening', serverListening)
    server.listen(global.environment.server.port)

    const unhandledRejectionHandler = (err) => {
      const log = global.logger || console
      log.error('Unhandled Promise Rejection: err: ', err.message)
      log.error(err.stack)
    }

    const gracefulShutdownHandler = async () => {
      global.logger.info('Server received shutdown signal')
      this.#isReady = false

      global.logger.info('Waiting for open connections to be finished')
      await httpTerminator.terminate()

      global.logger.info('Server is closed')
      process.exit(0)
    }

    process.on('unhandledRejection', unhandledRejectionHandler)
    process.on('SIGINT', gracefulShutdownHandler)
    process.on('SIGTERM', gracefulShutdownHandler)
  }
}
