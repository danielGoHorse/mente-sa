/* FeeGetByCifUseCase.js
 * ........................... outras importações .......................... */

export default class FeeGetByCifUseCase {
  async execute ({ customerAccount }) {
    /* ............ a lógica que já estava funcionando permanece ........... */

    // ── NOVA CHAMADA ────────────────────────────────────────────────────
    const currentPkgRows =
      await this.#getPackageDataFromCurrentSQL(customerAccount[0].cifno); // ★

    /* se você quiser anexar esses dados a cada fee/account */
    customerAccount.forEach(acc => {
      // procura o registro da sp cujo DDA bate com este account
      const row = currentPkgRows.find(r => r.ddaNumber === acc.ddaNumber);
      if (row) Object.assign(acc, row);
    });

    /* … resto do método … */
  }

  /* ------------------------------------------------------------------- */
  async #getPackageDataFromCurrentSQL (cifno) {          // ★ parâmetro
    const conn  = await connectToFeeMgmtDb();

    // passa o nome correto do parâmetro; o valor vem de cifno
    const rows =
      await executeStoreProcedure(conn, 'sp_GetConductorFees', { CIF: cifno }); // ★

    if (!rows?.length) return [];

    // a procedure devolve várias linhas; transformamos cada uma:
    return rows.map(r => ({
      cifno:            r.CIFNO?.trim(),
      ddaNumber:        String(r.DDANumber).trim(),
      bpsAcctNumber:    r.BPSAcctNumber?.trim() || '',
      feeType:          Number(r.FeeType),
      feeDescription:   r.FeeDescription?.trim()   || '',
      feeCode:          r.FeeCode?.trim()          || '',
      bpsFeeTypeCode:   r.BPSFeeTypeCode?.trim()   || '',
      feeAmount:        Number(r.FeeAmount),
      source:           r.Source?.trim()           || '',
      entity:           r.Entity?.trim()           || '',
      isFeesStandard:   r.IsFeesStandard?.trim()   || ''        // ★ nome certo
    }));
  }

  /* #getPackageDataFromSQL, #getDocumentUrl e #getFeeStandard permanecem */
}
