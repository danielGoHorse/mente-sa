import { Fee } from '#src/models/entities/Fees.js'
import Result from '#features/shared/result.js'
import CustomerFees from '#src/models/CustomerFees.js'
import BankAccountFee from '#src/models/BankAccountFee.js'
import InvestimentAccountFee from '#src/models/InvestimentAccountFee.js'
import { FeeCase } from '#src/models/entities/FeeCase.js'
import { Field } from '#src/models/entities/Fields.js'
import {
  connectToFeeMgmtDb,
  executeStoreProcedure
} from '#core/data/mssql/index.js';

const deParaFeeCodes = {
    "BPS005": 1, // Exemplo: Código do SQL → Código esperado no MongoDB
    "JH006": 3,
    "XYZ123": 7,
    // Adicione mais conforme necessário
};

export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    const result = { fees: [] };
    
    // Buscar e estruturar os dados do SQL
    const fees = await this.#getFeesStructuredFromSQL(customerAccount);
    
    const customer = new CustomerFees(fees, customerAccount);
    if (customer.fee) result.fees.push(customer.fee);
    
    const bank = new BankAccountFee(fees, customerAccount);
    if (bank.fee) result.fees.push(bank.fee);
    
    const equityField = await Field.find({ code: 7 });
    const investiment = new InvestimentAccountFee(
      fees,
      customerAccount,
      equityField[0]
    );
    if (investiment.fee?.feeGroups) result.fees.push(investiment.fee);
    
    const feesActives = await FeeCase.find({
      cif: customerAccount[0].cifno,
      status: {
        $nin: ['DONE', 'REJECTED']
      },
      caseNumber: {
        $exists: true
      }
    });
    
    result.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id
    }));

    result.documentUrl =
      'https://minio-ui.dev.k8s.safra.int/api/v1/buckets/jarvis-public/objects/download?preview=true&prefix=U2NoZWR1bGVPZkZlZXMucGRm';

    return Result.ok(result);
  }

  async #getFeesStructuredFromSQL(customerAccount) {
    // Obter os dados do SQL
    const feesData = await this.#getFeesFromSQL(customerAccount[0].cifno);
    
    // Estruturar os dados agrupados
    const groupedFees = {};

    for (const fee of feesData) {
        const { FeeType, FeeDescription, FeeCode, FeeAmount, Frequency } = fee;

        // Converter FeeCode via de/para
        const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;

        // Criar feeType se ainda não existir
        if (!groupedFees[FeeType]) {
            groupedFees[FeeType] = {
                feeType: FeeType,
                feeGroups: [{
                    name: "Standard Fees",
                    code: 1, // Código fixo para agrupar como "Standard Fees"
                    fields: []
                }]
            };
        }

        // Adicionar campo ao grupo de fees
        groupedFees[FeeType].feeGroups[0].fields.push({
            code: mappedCode,
            name: FeeDescription,
            defaultValue: FeeAmount ? FeeAmount.toString() : "",
            tooltip: Frequency ? `Charged: ${Frequency}` : "",
            isException: false
        });
    }
    
    return Object.values(groupedFees);
  }

  async #getFeesFromSQL(cifno) {
    const connection = await connectToFeeMgmtDb();
    return executeStoreProcedure(connection, 'sp_get_fees_byCIF', { cifno });
  }
}
