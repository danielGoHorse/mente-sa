import Result from '#features/shared/result.js'
import { FeeCase } from '#src/models/entities/FeeCase.js'

function formatMessage(result, userNameFull, updatedAt) {
  return `${result} by ${userNameFull} on ${new Date(
    updatedAt
  ).toLocaleDateString('en-US')}`
}

function findApprover(field, approver) {
  global.logger.info('findApprover()')
  const result = field.results.get(approver.userName.toUpperCase())
  if (!result) return null

  const message = formatMessage(result, approver.userNameFull, approver.updatedAt)
  return {
    message,
    approved: result === 'Approved',
    note: field.rejectComment
  }
}

function processCommonApprover(feeCase, feeGroup, commonApprover) {
  global.logger.info('processCommonApprover()')
  const approvers = []

  const field = feeGroup.fields.find(
    (field) => field.hasChanged && (field.approved || field.reject)
  )
  if (!field) return approvers

  if (!field.results) {
    field.results = {}
  } else {
    const commonApproverResult = findApprover(field, commonApprover)
    if (commonApproverResult) {
      approvers.push(commonApproverResult)
    }

    const equityApprover = feeCase.equityTeam.find((user) => user.result)
    if (equityApprover) {
      const equityField = feeGroup.fields.find(
        (field) =>
          field.results &&
          !!field.results.get(equityApprover.userName.toUpperCase())
      )

      if (equityField) {
        const equityApproverResult = findApprover(equityField, equityApprover)
        if (equityApproverResult) approvers.push(equityApproverResult)
        equityField.results = Object.fromEntries(field.results)
      }
    }

    if (field.results instanceof Map) {
      field.results = Object.fromEntries(field.results)
    }
  }

  return approvers
}

function resetLastFieldBasedOnConditions(lastField, lastOption, feeCase) {
  if (
    lastOption.text === 'Other' &&
    lastOption.value !== '' &&
    feeCase.status === 'PENDING_EQUITY' &&
    lastField.approved
  ) {
    delete lastField.approved
    delete lastField.reject
    delete lastField.rejectComment
  }
}

export default class FeeCaseGetByIdAndUserNameUseCase {
  async execute({ feeId, userName }) {
    global.logger.info(`FeeCaseGetByIdAndUserNameUseCase(fee=${feeId}, userName=${userName})`)

    const strategyForStatus = {
      INITIAL: 'usersApprovers',
      PENDING_APPROVAL: 'usersApprovers',
      PENDING_EQUITY: 'equityTeam',
      PENDING_SECOPS: 'secopsTeam',
      VISIBLE_ONLY: 'visibleToUsers'
    }
    const strategyForApprover = {
      INITIAL: 'canApprove',
      PENDING_APPROVAL: 'canApprove',
      PENDING_EQUITY: 'canEditEquity',
      PENDING_SECOPS: 'canEditSecops'
    }

    const hasFee = await FeeCase.exists({ _id: feeId })
    if (!hasFee) {
      return Result.fail('Fee case not found')
    }

    // Carrega feeCase do banco
    const feeCase = await (await FeeCase.findById(feeId)).toObject()

    // Exemplo: você pode ter guardado esses dados no feeCase ou pode vir de outro lugar.
    // Se não estiver no feeCase, poderá vir de outro repositório / service.
    // Aqui apenas simulo que já está no feeCase ou algo do tipo:
    feeCase.documentUrl =
      'https://minio-ui.dev.k8s.safra.int/api/v1/buckets/jarvis-public/objects/download?preview=true&prefix=U2NoZWR1bGVPZkZlZXMucGRm'

    const feesActives = await FeeCase.find({
      cif: feeCase.cif,
      status: { $nin: ['DONE', 'REJECTED'] },
      caseNumber: { $exists: true }
    })
    feeCase.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id
    }))

    // Lógica para remover, aprovar, etc. se status não for INITIAL ou PENDING_APPROVAL
    if (!['INITIAL', 'PENDING_APPROVAL'].includes(feeCase.status)) {
      feeCase.fees.forEach((fee) => {
        fee.feeGroups.forEach((feeGroup) => {
          if (feeGroup.name !== 'Exception Request') return

          const lastField = feeGroup.fields.slice(-1)[0]
          const lastOption = lastField.exceptionOptions.slice(-1)[0]

          const commonApprover = feeCase.usersApprovers.find((user) => user.result)
          if (commonApprover) {
            feeGroup.approvalResults = processCommonApprover(feeCase, feeGroup, commonApprover)
          }
          resetLastFieldBasedOnConditions(lastField, lastOption, feeCase)
        })
      })
    }

    // Se for o usuário dono
    if (feeCase?.userOwner?.toUpperCase() === userName?.toUpperCase()) {
      feeCase.canApprove = false

      // Aqui, ou no final, injetamos manualmente alguns campos se necessário
      // feeCase.branchCity = ...
      // feeCase.branchType = ...
      // feeCase.defaultPackageType = ...
      // feeCase.feePackage = ...

      return Result.ok(feeCase)
    }

    // Descobre qual property gerencia a lista de usuários aprovadores nesse status
    const userListProperty = strategyForStatus[feeCase.status]
    // Descobre a property que define a permissão de approval
    const canApproveProperty = strategyForApprover[feeCase.status]

    // Verifica se userName está em feeCase[userListProperty] => se sim, pode aprovar
    if (
      feeCase[userListProperty] &&
      feeCase[userListProperty].some(
        (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
      )
    ) {
      feeCase[canApproveProperty] = true

      if (
        feeCase.status === 'PENDING_APPROVAL' &&
        feeCase[userListProperty]
          .filter((x) => x.userName?.toUpperCase() === userName?.toUpperCase())[0]
          ?.signature.includes('AAA')
      ) {
        feeCase.canSeeRevenueReport = true
      }

      // Aqui também podemos injetar os campos extras:
      // feeCase.branchCity = ...
      // feeCase.branchType = ...
      // feeCase.defaultPackageType = ...
      // feeCase.feePackage = ...

      return Result.ok(feeCase)
    }

    // Senão, tentamos ver se userName aparece em ANY do strategyForStatus => canSeeCase
    const propertys = Object.keys(strategyForStatus)
    let canSeeCase = false
    for (const property of propertys) {
      const userProperty = strategyForStatus[property]
      if (
        feeCase[userProperty] &&
        feeCase[userProperty].some(
          (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
        )
      ) {
        canSeeCase = true
        break
      }
    }

    if (canSeeCase) {
      // Injetar manualmente aqui também se quiser
      // feeCase.branchCity = ...
      // feeCase.branchType = ...
      // feeCase.defaultPackageType = ...
      // feeCase.feePackage = ...

      return Result.ok(feeCase)
    }

    return Result.fail('Not found')
  }
}
