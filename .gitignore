export default class CustomerFees {
  #customer = {};
  #accounts = [];

  constructor(fees, accounts) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }

    // Seleciona o fee cujo feeType seja "Customer Fees"
    this.#customer = fees.filter((x) => x.feeType === "Customer Fees")[0];
    if (!this.#customer || !Array.isArray(this.#customer.feeGroups)) {
      throw new Error('Customer Fees or feeGroups are undefined');
    }

    if (!accounts || !Array.isArray(accounts) || accounts.length === 0) {
      throw new Error('Accounts is empty or undefined');
    }

    this.#accounts = accounts;

    // Atualiza os valores dos fees atuais com base no kycMailingStatus
    this.#updateCurrentClientFees();
  }

  #updateCurrentClientFees() {
    // Usamos a primeira conta como referência para o kycMailingStatus
    const account = this.#accounts[0];

    for (const feeGroup of this.#customer.feeGroups) {
      if (feeGroup.name === "Client Current Fees") {
        for (const field of feeGroup.fields) {
          // Se o kycMailingStatus for "Standard", forçamos o valor para "NOT APPLICABLE"
          if (account.kycMailingStatus === "Standard") {
            field.defaultValue = "NOT APPLICABLE";
            field.labelValue = "NOT APPLICABLE";
            console.log(
              `Debug CustomerFees - Campo ${field.code} no grupo "${feeGroup.name}" definido como NOT APPLICABLE por kycMailingStatus "${account.kycMailingStatus}"`
            );
          } else {
            // Caso contrário, se houver um valor numérico, formata como moeda
            const numValue = parseFloat(field.defaultValue);
            field.labelValue =
              !isNaN(numValue) ? "$" + numValue.toFixed(2) : field.defaultValue;
          }
        }
      } else if (feeGroup.name === "Standard Fees") {
        // Apenas formata os valores numéricos para os Standard Fees
        for (const field of feeGroup.fields) {
          const numValue = parseFloat(field.defaultValue);
          field.labelValue =
            !isNaN(numValue) ? "$" + numValue.toFixed(2) : field.defaultValue;
        }
      }
      // O grupo "Exceptions Request" pode manter seus valores originais
    }
  }

  get fee() {
    return this.#customer;
  }
}
