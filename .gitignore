
import { FeeGroup } from './entities/FeeGroups.js';
import numberToCurrency from '../core/helpers/currency.js';

export default class InvestmentAccountFee {
  #feeName = 'Investment Account Fees';
  #investiment = {};
  #accounts = [];
  #accountsDDA = [];
  #allExceptions = new Set();

  constructor(fees, accounts, equityField) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }
    // Seleciona o objeto cujo FeeType seja "Investment Account Fees"
    this.#investiment = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (
      !this.#investiment ||
      !Array.isArray(this.#investiment.feeGroups) ||
      !this.#investiment.feeGroups.length
    ) {
      this.#investiment = {};
      return;
    }

    // Filtra as contas de investimento (feeType === 3)
    this.#accounts = accounts.filter((x) => x.feeType === 3);
    if (this.#accounts.length < 1) {
      this.#investiment = {};
      return;
    }

    // Para cada conta, cria itens para os códigos 5 e 7 (para Investment)
    this.#accounts.forEach((acc) => {
      if (acc.ddaNumber) {
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 5,
          entity: acc.entity || null,
        });
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 7,
          entity: acc.entity || null,
        });
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 6,
          entity: acc.entity || null,
        });
        this.#accountsDDA.push({
          number: acc.ddaNumber,
          code: 9,
          entity: acc.entity || null,
        });
      }
    });

    // Deduplica os itens de accountsDDA com base na chave composta "number-code"
    this.#accountsDDA = Array.from(
      new Map(this.#accountsDDA.map(item => [`${item.number}-${item.code}`, item])).values()
    );

    this.#addMultiplesAccount(this.#accounts[0].cifno);
    this.#addCurrentClientValue(equityField);
  }

  get fee() {
    if (!this.#investiment || !this.#investiment.feeGroups) {
      return null;
    }
    return this.#investiment;
  }

  // Deduplica os fields com base no fee code
  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  /**
   * Para cada feeGroup de investimento e para cada conta única (accountsDDA),
   * clona o feeGroup atribuindo o número da conta (accountNumber) e o entityCode.
   * Se o grupo vier com fields vazio, insere um field default para evitar erros no front.
   */
  #addMultiplesAccount(cif) {
    const result = {};

    for (const feeGroup of this.#investiment.feeGroups) {
      // Garante que fields esteja definido
      feeGroup.fields = feeGroup.fields || [];
      // Clona os fields para evitar referências compartilhadas
      feeGroup.fields = feeGroup.fields.map((field) => ({
        ...field,
        exceptionOptions: field.exceptionOptions
          ? field.exceptionOptions.map((opt) => ({ ...opt }))
          : []
      }));

      for (const account of this.#accountsDDA) {
        if (!result[account.number]) {
          result[account.number] = {};
        }
        // Filtra os fields do grupo que correspondem ao código (5 ou 7)
        let fieldsForAccount = feeGroup.fields.filter((x) => x.code === account.code);
        // Se não houver fields para esta conta, insere um fallback para evitar erro no front
        if (fieldsForAccount.length === 0) {
          fieldsForAccount.push({
            code: account.code,
            name: '',
            defaultValue: '',
            tooltip: '',
            isException: true,
            exceptionOptions: []
          });
        }
        if (!result[account.number][feeGroup.name]) {
          result[account.number][feeGroup.name] = [];
          // Processa as exceptionOptions para agregar em allExceptions
          feeGroup.fields.forEach((item) => {
            item.exceptionOptions = item.exceptionOptions.filter((x) => !x.retired);
            item.exceptionOptions.forEach(this.#allExceptions.add, this.#allExceptions);
          });
          const newFeeGroup = new FeeGroup({
            name: feeGroup.name,
            fields: fieldsForAccount,
            cif,
            accountNumber: account.number,
            visible: feeGroup.visible,
            code: feeGroup.code,
            entityCode: account.entity,
          });
          result[account.number][feeGroup.name].push(newFeeGroup);
        } else {
          const feeGroupToAddFields = result[account.number][feeGroup.name][0];
          feeGroupToAddFields.fields = [...feeGroupToAddFields.fields, ...fieldsForAccount];
        }
      }
    }

    // Agrupa os feeGroups por conta
    const feeGroupsByAccount = Object.keys(result).reduce((acc, accountNumber) => {
      Object.keys(result[accountNumber]).forEach((groupName) => {
        acc.push(result[accountNumber][groupName]);
      });
      return acc;
    }, []);

    this.#investiment.feeGroups = [];
    for (const feeGroups of feeGroupsByAccount) {
      for (const feeGroup of feeGroups) {
        this.#investiment.feeGroups.push(feeGroup);
      }
    }
  }

  /**
   * Atualiza os valores dos fields para cada FeeGroup de investimento.
   * Para o field com código 5 (que traz um valor textual completo, como "$0.10 per share, min charge of $150 per trade"),
   * define labelValue igual a defaultValue; para os demais, tenta converter defaultValue para número e formata como moeda.
   * A correspondência é feita usando a lista deduplicada accountsDDA.
   */
  #addCurrentClientValue(equityField) {
    // Converte as exceptionOptions para array
    const exceptionsOptions = Array.from(this.#allExceptions);
    for (const feeGroup of this.#investiment.feeGroups) {
      feeGroup.cif = this.#accounts[0]?.cifno || null;
      for (const field of feeGroup.fields) {
        if (field.isException) {
          field.labelValue = field.labelValue || '';
        } else {
          // Para cada field, encontra a conta correspondente (baseada no número e no código)
          const corresponding = this.#accountsDDA.find(
            (acc) =>
              acc.number.toString() === feeGroup.accountNumber.toString() &&
              acc.code === field.code
          );
          if (corresponding) {
            if (field.code === 9 && field.code === 7) {
              // Para o código 5, deixa o valor textual intacto
              field.labelValue = field.defaultValue;
            } else {
              const numValue = parseFloat(field.defaultValue);
              field.labelValue =
                !isNaN(numValue) ? "$" + numValue.toFixed(2) : field.defaultValue;
            }
          }
        }
      }
    }
    this.#clearMemory();
  }

  #clearMemory() {
    this.#accounts = [];
    this.#accountsDDA = [];
    this.#allExceptions = new Set();
  }
}
