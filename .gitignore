async #getFeesStructuredFromSQL(customerAccount) {
    const feesData = await this.#getFeesFromSQL(customerAccount[0].cifno);

    const feePackageId = feesData[0]?.['Default Fee Package Id'];
    if (!feePackageId) {
        throw new Error('Default Fee Package Id not found in feesData');
    }

    const accounts = feesData.map((fee) => ({
        cifno: fee.CIFNO,
        ddaNumber: fee.ACCTNO,
        branchCity: fee['Branch City'],
        branchState: fee['Branch State'],
        branchType: fee['Branch Type'],
        defaultPackageType: fee['Default Package Type'],
        feePackage: fee['Default Fee Package']?.trim() || '',
        defaultFeePackageId: fee['Default Fee Package Id'] || '',
        feeType: this.#mapFeeType(fee.FeeType),
        feeGroup: 1,
        kycMailingStatus: fee.StandardException === 'Standard' ? 'Standard' : 'Hold Mail',
    }));

    const groupedFees = {};

    for (const fee of feesData) {
        const {
            FeeType,
            FeeDescription,
            FeeCode,
            FeeAmount,
            Frequency,
            DefaultFeeAmount,
            DefaultFrequency,
        } = fee;

        const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;

        if (
            (FeeType === 'Customer Fees' && ![1, 2].includes(mappedCode)) ||
            (FeeType === 'Bank Account Fees' && ![3, 4].includes(mappedCode)) ||
            (FeeType === 'Investment Account Fees' && ![5, 6, 7].includes(mappedCode)) ||
            excludedCodes.has(mappedCode) 
        ) {
            continue;
        }

        if (!groupedFees[FeeType]) {
            groupedFees[FeeType] = {
                feeType: FeeType,
                feeGroups: [],
            };
        }

        let standardGroup = groupedFees[FeeType].feeGroups.find(
            (group) => group.name === 'Standard Fees'
        );
        if (!standardGroup) {
            standardGroup = {
                name: 'Standard Fees',
                code: 1,
                fields: [],
            };
            groupedFees[FeeType].feeGroups.push(standardGroup);
        }

        standardGroup.fields.push({
            code: mappedCode,
            name: FeeDescription,
            defaultValue: FeeAmount ? FeeAmount.toString() : '',
            tooltip: Frequency ? Frequency : '',
            isException: false,
        });

        let clientCurrentGroup = groupedFees[FeeType].feeGroups.find(
            (group) => group.name === 'Client Current Fees'
        );
        if (!clientCurrentGroup) {
            clientCurrentGroup = {
                name: 'Client Current Fees',
                code: 2,
                fields: [],
            };
            groupedFees[FeeType].feeGroups.push(clientCurrentGroup);
        }

        clientCurrentGroup.fields.push({
            code: mappedCode,
            name: FeeDescription,
            defaultValue: DefaultFeeAmount ? DefaultFeeAmount.toString() : '',
            tooltip: DefaultFrequency ? DefaultFrequency : '',
            isException: false,
        });
    }

    // Buscar exceptions e adicionar dentro de exceptionOptions nos fields de Exceptions Request
    const exceptions = await this.#getExceptionFeesFromSQL(feePackageId);
    
    for (const exception of exceptions) {
        const { code, name, defaultValue, tooltip, isException } = exception;

        // Encontrar o feeType que tem esse cÃ³digo
        const feeType = Object.keys(groupedFees).find((type) =>
            groupedFees[type].feeGroups.some((group) =>
                group.fields.some((field) => field.code === code)
            )
        );

        if (!feeType) {
            console.warn(`FeeType not found for exception code: ${code}`);
            continue;
        }

        let exceptionGroup = groupedFees[feeType]?.feeGroups.find(
            (group) => group.name === 'Exceptions Request'
        );

        if (!exceptionGroup) {
            exceptionGroup = {
                name: 'Exceptions Request',
                code: 3,
                fields: [],
            };
            groupedFees[feeType]?.feeGroups.push(exceptionGroup);
        }

        let existingField = exceptionGroup.fields.find(field => field.code === code);

        if (!existingField) {
            // Criar um novo campo para essa exception
            existingField = {
                code,
                name,
                defaultValue,
                tooltip,
                isException,
                exceptionOptions: [] // Iniciamos o array para adicionar exceptions dentro
            };
            exceptionGroup.fields.push(existingField);
        }

        // Adicionar as exceptions dentro do campo correspondente
        existingField.exceptionOptions.push({
            code,
            name,
            defaultValue,
            tooltip,
            isException
        });
    }

    return { groupedFees: Object.values(groupedFees), accounts };
}
