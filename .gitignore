import Result from '#features/shared/result.js';

export default class FeeCaseGetByCifUseCase {
  async execute({ cif }, feeManagementModel, customerModel) {
    const [errCustomer, responseCustomer] = await customerModel.getCustomerDetailsByCif(cif);
    if (errCustomer) {
      return Result.fail({ message: "It's not possible to get address cif" });
    }

    const customerData = responseCustomer?.data?.customer || {};
    const [errFee, responseFee] = await feeManagementModel.getFeeByAccount(customerData);
    if (errFee) {
      return Result.fail({ message: "It's not possible to get fee values" });
    }

    function normalizeFeeName(text) {
      return text
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/[_-]/g, ' ')
        .trim();
    }

    const feesData = responseFee?.data || {};
    const timestamp = new Date().toISOString();

    const packageName = feesData.feePackage || "N/A";
    const packageType = feesData.defaultPackageType || "N/A";
    const branchType = feesData.branchType || "N/A";

    const currentFees = [
      ...(customerData?.customerCurrentFees?.map(x => ({
        feeDescription: x.feeDescription || '',
        feeCode: x.feeCode || ''
      })) || []),
      ...(feesData?.currentFees || [])
    ];

    // Mapa de FeeType
    const feeTypeMap = {
      1: "Customer Fees",
      2: "Bank Account Fees",
      3: "Investment Account Fees"
    };

    // Mapa de FeeCode
    const feeCodeMap = {
      "Account Maintenance": 1,
      "Hold Mail": 2,
      "Incoming Wire": 3,
      "Outgoing Wire": 4,
      "Safekeeping Custody": 6,
      "SSL Account Maintenance": 5,
      "Equity and Options Commission": 7,
      "FX Outgoing Wire Fee": 8,
      "US Equities Commission": 10,
      "Options Commission": 11
    };

    // Filtrar accounts apenas daqueles FeeTypes que interessam
    const rawCustomerAccounts = customerData?.customerAccount || [];
    const filteredCustomerAccounts = rawCustomerAccounts.filter(fee => {
      const feeTypeString = feeTypeMap[fee.feeType] || "";
      return [
        "Customer Fees",
        "Bank Account Fees",
        "Investment Account Fees"
      ].includes(feeTypeString);
    });

    // Construir "formattedFees" a partir dos dados do customer
    const formattedFees = filteredCustomerAccounts.map(fee => {
      const normalizedFeeName = normalizeFeeName(fee.feeDescription);
      return {
        feeType: feeTypeMap[fee.feeType] || "",
        feeGroups: [
          {
            // Se fee.feeGroup === 1, definimos "Client Current Fees", senão "Standard Fees".
            // Ajuste conforme sua própria regra.
            name: fee.feeGroup === 1 ? "Client Current Fees" : "Standard Fees",
            visible: true,
            kycMailingStatus: fee.kycMailingStatus || null,
            code: fee.feeCode || "",
            accountNumber: fee.ddaNumber || "",
            cif: fee.cifno || "",
            id: "",
            fields: [
              {
                hasChanged: false,
                code: feeCodeMap[normalizedFeeName] || fee.feeCode || "",
                name: normalizedFeeName,
                defaultValue: fee.feeAmount?.toString() || "",
                isStandard: fee.isFeesStandard === "Yes",
                isException: fee.isFeesStandard === "No",
                isCurrentClient: false,
                labelValue: fee.feeAmount ? `$${fee.feeAmount.toFixed(2)}` : "",
                tooltip: fee.source ? `Source: ${fee.source}` : "",
                exceptionOptions: [],
                createdAt: timestamp,
                updatedAt: timestamp,
                id: fee.ddaNumber?.toString() || ""
              }
            ]
          }
        ],
        id: ""
      };
    });

    // Construir "formattedFeeGroups" a partir do "feesData" original
    const formattedFeeGroups =
      feesData?.fees
        ?.filter(feeGroup =>
          ["Customer Fees", "Bank Account Fees", "Investment Account Fees"].includes(
            feeGroup.feeType
          )
        )
        .map(feeGroup => ({
          feeType: feeGroup.feeType,
          id: "",
          feeGroups: feeGroup.feeGroups.map(group => ({
            ...group,
            id: group.id || "",
            cif: group.cif || "",
            accountNumber: group.accountNumber || "",
            fields: group.fields.map(field => ({
              ...field,
              hasChanged: field.hasChanged || false,
              createdAt: field.createdAt || timestamp,
              updatedAt: field.updatedAt || timestamp,
              id: field._id || field.id || "",
              exceptionOptions:
                field.exceptionOptions?.map(opt => ({
                  ...opt,
                  parameterOptionId: opt.parameterOptionId || ""
                })) || []
            }))
          }))
        })) || [];

    // Juntamos ambos em um só array
    const allFees = [...formattedFees, ...formattedFeeGroups];

    // Defina os 3 feeTypes que você quer exibir/retornar
    const feeTypesToGroup = [
      "Customer Fees",
      "Bank Account Fees",
      "Investment Account Fees"
    ];

    // AGRUPAMENTO FINAL:
    // 1) Agrupa todos os feeGroups por feeType
    // 2) Depois, dentro de cada feeType, agrupa por name
    const groupedFees = feeTypesToGroup.map(type => {
      // Filtra tudo que tiver esse feeType
      const itemsOfThisType = allFees.filter(item => item.feeType === type);

      // Unir todos os feeGroups desses itens
      const combinedFeeGroups = itemsOfThisType.flatMap(item => item.feeGroups || []);

      // Agrupar pelo campo 'name' => ["Standard Fees", "Client Current Fees", "Exception Request"]
      // Ajuste caso sua regra de negócio identifique Exception Request de outra forma.
      const nameMap = {
        "Standard Fees": [],
        "Client Current Fees": [],
        "Exception Request": []
      };

      // Percorre todos os feeGroups combinados e insere no array correto
      for (const group of combinedFeeGroups) {
        if (group.name === "Standard Fees") {
          nameMap["Standard Fees"].push(group);
        } else if (group.name === "Client Current Fees") {
          nameMap["Client Current Fees"].push(group);
        } else {
          // Qualquer outro 'name' cai em "Exception Request"
          nameMap["Exception Request"].push(group);
        }
      }

      // Monta um array final para cada nome de grupo
      // Caso deseje retornar mesmo os grupos vazios, remova o .filter(...)
      const feeGroups = Object.entries(nameMap)
        .map(([name, groups]) => ({
          name,
          feeGroups: groups
        }))
        .filter(obj => obj.feeGroups.length > 0);

      return {
        feeType: type,
        feeGroups
      };
    });

    const result = {
      customerName: customerData?.customerAddress?.name || feesData?.customerName || '',
      customerShortName: feesData?.customerShortName || '',
      customerAddress: customerData?.customerAddress?.address || '',
      customerAccountOfficer: customerData?.customerAddress?.officer || '',
      cif: customerData?.customerAddress?.cif || cif,
      officerId: feesData?.officerId || '',
      branchCity: feesData?.branchCity || '',
      branchState: feesData?.branchState || '',
      branchType,
      feePackage: feesData?.feePackage || '',
      defaultFeePackageId: feesData?.defaultFeePackageId || '',
      defaultPackageType: feesData?.defaultPackageType || '',
      packageName,
      packageType,
      fees: groupedFees,           // <-- Aqui está o agrupamento por feeType e depois por name
      feesActives: feesData?.feesActives || [],
      documentUrl: feesData?.documentUrl || '',
      currentFees
    };

    global.logger.info('End process');
    return Result.ok(result);
  }
}
