import { Fee } from '#src/models/entities/Fees.js';
import Result from '#features/shared/result.js';
import CustomerFees from '#src/models/CustomerFees.js';
import BankAccountFee from '#src/models/BankAccountFee.js';
import InvestimentAccountFee from '#src/models/InvestimentAccountFee.js';
import { FeeCase } from '#src/models/entities/FeeCase.js';
import { Field } from '#src/models/entities/Fields.js';
import {
  connectToFeeMgmtDb,
  executeStoreProcedure,
} from '#core/data/mssql/index.js';

export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    /* 1 ─ modelo‑padrão (Mongo) */
    const baseFees = await this.#getFeeStandard([
      { feeType: 'Customer Fees' },
      { feeType: 'Bank Account Fees' },
      { feeType: 'Investment Account Fees' },
    ]);

    /* 2 ─ dados de SQL */
    const cif = customerAccount[0].cifno;
    const packageId = 1;          // TODO: trocar pelo valor real quando vier

    const conn = await connectToFeeMgmtDb();
    try {
      const [
        [pkgRow] = [],
        stdRows,
        excRows
      ] = await Promise.all([
        executeStoreProcedure(conn, 'sp_get_fees_byCIF',           { cifno: cif }),
        executeStoreProcedure(conn, 'sp_get_standard_fees_bypackage',   { packageId }),
        executeStoreProcedure(conn, 'sp_get_exception_fees_bypackage',  { packageId }),
      ]);

      /* 2.1 ─ info de package/branch (primeira proc) */
      const pkgData = pkgRow ? {
        defaultFeePackageId: pkgRow['Default Fee Package Id'] ?? null,
        branchCity:          pkgRow['Branch City']?.trim()      || '',
        branchState:         pkgRow['Branch State']?.trim()     || '',
        branchType:          pkgRow['Branch Type']?.trim()      || '',
        defaultPackageType:  pkgRow['Default Package Type']?.trim() || '',
        feePackage:          pkgRow['Default Fee Package']?.trim()  || '',
      } : {};

      /* 2.2 ─ cria 2 maps: Standard( feeType -> amount ) e Exceptions( feeCode -> amount ) */
      const stdAmt  = Object.fromEntries(
        stdRows.map(r => [Number(r.FeeType), Number(r.FeeAmount)])
      );
      const excAmt  = Object.fromEntries(
        excRows.map(r => [r.FeeCode.trim(), Number(r.Amount)])
      );

      /* 2.3 ─ injeta valores nas contas vindas do Conductor            *
       *       – se existir Amount Standard para feeType   -> defaultValue
       *       – senão, se existir Amount Exception para feeCode -> defaultValue
       */
      customerAccount = customerAccount.map(acc => ({
        ...acc,
        ...pkgData,
        defaultValue:
          stdAmt[acc.feeType] ??
          excAmt[acc.feeCode] ??
          acc.feeAmount,          // fallback ao valor recebido do Conductor
      }));

      /* 3 ─ builders (mantidos) */
      const result = { fees: [] };

      const builders = [
        new CustomerFees(baseFees, customerAccount),
        new BankAccountFee(baseFees, customerAccount),
        new InvestimentAccountFee(
          baseFees,
          customerAccount,
          await Field.findOne({ code: 7 })
        ),
      ];

      builders
        .filter(b => b.fee && b.fee.feeGroups?.length)
        .forEach(b => result.fees.push(b.fee));

      /* 4 ─ casos ativos */
      const feesActives = await FeeCase.find({
        cif,
        status: { $nin: ['DONE', 'REJECTED'] },
        caseNumber: { $exists: true },
      });
      result.feesActives = feesActives.map(({ caseNumber, id }) => ({ caseNumber, id }));

      /* 5 ─ accounts detalhados */
      const docUrl = this.#getDocumentUrl(pkgData.defaultFeePackageId);
      result.accounts = customerAccount.map(acc => ({
        cifno:               acc.cifno,
        ddaNumber:           acc.ddaNumber,
        branchCity:          acc.branchCity,
        branchState:         acc.branchState,
        branchType:          acc.branchType,
        defaultPackageType:  acc.defaultPackageType,
        feePackage:          acc.feePackage,
        defaultFeePackageId: acc.defaultFeePackageId,
        defaultFeePackage:   acc.defaultFeePackage,
        documentUrl:         docUrl,
      }));

      result.documentUrl = docUrl;
      return Result.ok(result);
    } finally {
      await conn.close();   // evita “Global connection already exists…”
    }
  }

  /* ---------- helpers ---------- */

  async #getFeeStandard(filter) {
    return Fee.find({ $or: filter })
              .select({ feeType: 1, feeGroups: { name: 1, fields: 1, code: 1 } })
              .lean();
  }

  #getDocumentUrl(id) {
    const key = ({ 1: 'intlPB3', 2: 'uSPBIndividual3', 3: 'uSPBCorporation3' })[id];
    return key ? (global.environment.scheduleUrls?.[key] || '') : '';
  }
}
