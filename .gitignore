function parseHistoryToMock(history) {
  // Função para agrupar approvals
  function groupApprovals(steps) {
    // Seleciona todos steps "Approvals and Restrictions:"
    const approvalSteps = steps.filter(step =>
      step.name && step.name.startsWith('Approvals and Restrictions')
    );
    // Para cada pessoa que deveria aprovar, pega os dados (mock espera um array de people)
    const people = [];
    approvalSteps.forEach(step => {
      if (step.permissions?.people && Array.isArray(step.permissions.people)) {
        step.permissions.people.forEach(person => {
          // No mock cada pessoa pode ter action como array, garantir isso
          people.push({
            ...person,
            // Aqui você pode adaptar os campos se quiser, ex:
            action: person.action || [],
          });
        });
      }
    });
    // Status geral: pending se algum pending, senão waiting/canceled/etc
    const status =
      approvalSteps.find(s => s.status === 'pending')?.status ||
      approvalSteps[0]?.status ||
      'pending';
    return {
      id: 3,
      name: "Approvals and Restrictions",
      status,
      successLabel: "Approved",
      permissions: {
        people
      }
    };
  }

  // Função para transformar um step "simples"
  function mapStep(step, mockData) {
    return {
      id: step.id,
      name: step.name,
      status: step.status,
      successLabel: step.successLabel || '',
      permissions: {
        people: (step.permissions?.people || []).map(p => ({
          ...p,
          action: p.action || [],
        }))
      }
    };
  }

  // 1. Transforma steps em formato mock
  const mockData = [];

  // 2. "Initiator"
  const initiatorStep = history.data.flat().find(s => s.name?.toLowerCase().includes("initiator"));
  if (initiatorStep) {
    mockData.push(mapStep(initiatorStep));
  }

  // 3. "Validations" ou "Validation"
  const validationStep = history.data.flat().find(s => s.name?.toLowerCase().includes("validation"));
  if (validationStep) {
    mockData.push({
      ...mapStep(validationStep),
      name: "Validations" // Normaliza nome
    });
  }

  // 4. "Approvals and Restrictions" agrupado
  mockData.push(groupApprovals(history.data.flat()));

  // 5. Restriction Removal
  const restrictionRemovalStep = history.data.flat().find(s => s.name?.toLowerCase().includes("restriction removal"));
  if (restrictionRemovalStep) {
    mockData.push(mapStep(restrictionRemovalStep));
  }

  // 6. "Wire Repair"
  const wireRepairStep = history.data.flat().find(s => s.name?.toLowerCase().includes("wire repair"));
  if (wireRepairStep) {
    mockData.push(mapStep(wireRepairStep));
  }

  // 7. "OFAC"
  const ofacStep = history.data.flat().find(s => s.name?.toLowerCase().includes("ofac"));
  if (ofacStep) {
    mockData.push(mapStep(ofacStep));
  }

  // 8. "Processing"
  const processingStep = history.data.flat().find(s => s.name?.toLowerCase().includes("processing"));
  if (processingStep) {
    mockData.push(mapStep(processingStep));
  }

  // 9. "Initiator Notified"
  const notifiedStep = history.data.flat().find(s => s.name?.toLowerCase().includes("initiator notified"));
  if (notifiedStep) {
    mockData.push(mapStep(notifiedStep));
  }

  // --- cardRowData e dataDisplayData, selectedBank
  // Apenas replica do original (pode customizar se quiser)
  return {
    status: history.status,
    data: mockData.map(item => [item]), // cada step como array (igual seu mock)
    cardRowData: history.cardRowData,
    dataDisplayData: history.dataDisplayData,
    selectedBank: history.selectedBank,
  };
}

// Exemplo de uso:
import history from './history.json'; // Seu history

const mockJson = parseHistoryToMock(history);

// Use mockJson como quiser no seu front (passa pro componente, salva, etc)
console.log(JSON.stringify(mockJson, null, 2));
