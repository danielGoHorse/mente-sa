const codeMap = exceptionsByFeeTypeAndCode[ft] || {};
for (const [codeStr, listExc] of Object.entries(codeMap)) {
  const code = Number(codeStr);
  let field = exceptionGroup.fields.find((f) => f.code === code);
  if (!field) {
    // Tenta obter o nome da exception a partir do objeto retornado; se estiver vazio,
    // procura no grupo "Standard Fees" pelo mesmo cÃ³digo.
    let fieldName = listExc[0].name;
    if (!fieldName) {
      const standardGroup = groupedFeesMap[ft]?.feeGroups.find((g) => g.name === 'Standard Fees');
      const stdField = standardGroup?.fields.find((f) => f.code === code);
      fieldName = stdField?.name || '';
    }
    field = {
      code,
      name: fieldName,
      defaultValue: listExc[0].defaultValue || '0',
      tooltip: listExc[0].tooltip || '',
      isException: true,
      exceptionOptions: [],
    };
    exceptionGroup.fields.push(field);
  }
  for (const exc of listExc) {
    const amountNumber = parseFloat(exc.defaultValue || '0');
    field.exceptionOptions.push({
      approvedByDoubleA: null,
      value: exc.defaultValue,            
      text: `$${amountNumber.toFixed(2)}`, 
      visible: true,
      retired: false,
      parameterOptionId: exc.parameterOptionId,
    });
  }
}


if (field.code === 2 && this.#customer.feeGroups[0].kycMailingStatus !== 'Hold Mail') {
  field.defaultValue = 'NOT APPLICABLE';
  field.labelValue = field.defaultValue;
  field.exceptionOptions = [
    {
      value: field.defaultValue,
      text: field.defaultValue
    }
  ];
}
