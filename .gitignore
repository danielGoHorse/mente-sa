import { FeeGroup } from './entities/FeeGroups.js';
import numberToCurrency from '../core/helpers/currency.js';

export default class CustomerFees {
  #feeName = 'Customer Fees';
  #customer = {};
  #accounts = [];

  constructor(fees, accounts) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }
    this.#customer = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (!this.#customer || !Array.isArray(this.#customer.feeGroups)) {
      throw new Error('Customer Fees or feeGroups are undefined');
    }
    if (!accounts || !Array.isArray(accounts) || accounts.length === 0) {
      throw new Error('Accounts is empty or undefined');
    }
    // Para Customer Fees, normalmente há apenas uma conta
    this.#accounts = [accounts[0]];

    this.#addMultiplesAccount(this.#accounts[0].cifno);
    this.#addCurrentClientValue();
  }

  /**
   * Deduplica os campos (fields) com base no fee code.
   */
  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  /**
   * Gera os feeGroups para a conta, clonando os grupos originais
   * e atribuindo o número da conta (accountNumber) e o kycMailingStatus.
   */
  #addMultiplesAccount(cif) {
    const feeGroupTemplates = this.#customer.feeGroups;
    const newFeeGroups = [];

    for (const template of feeGroupTemplates) {
      // Clona os fields para evitar referências compartilhadas
      let clonedFields = template.fields.map((field) => ({
        ...field,
        exceptionOptions: field.exceptionOptions
          ? field.exceptionOptions.map((opt) => ({ ...opt }))
          : []
      }));

      // Deduplica os fields com base no fee code
      clonedFields = this.#deduplicateFields(clonedFields);

      // Define o kycMailingStatus: utiliza o valor da conta, se existir, ou "Standard" como padrão.
      const kycMailingStatus = this.#accounts[0].kycMailingStatus || 'Standard';

      const newFeeGroup = new FeeGroup({
        name: template.name,
        fields: clonedFields,
        cif,
        accountNumber: this.#accounts[0].ddaNumber.toString(),
        visible: template.visible,
        code: template.code,
        kycMailingStatus // Garante que não venha null
      });
      newFeeGroups.push(newFeeGroup);
    }

    this.#customer.feeGroups = newFeeGroups;
  }

  /**
   * Atualiza os valores dos fees para cada grupo, definindo o labelValue com base no valor.
   * - Para "Client Current Fees" com code 2 e kycMailingStatus "Standard": valor é "NOT APPLICABLE".
   * - Para "Exception Request", se for Account Management (code 1) e NÃO houver alteração (hasChanged false),
   *   deixa o valor vazio (para que o front entenda que o usuário ainda não escolheu uma nova taxa).
   * - Caso contrário, formata o valor com numberToCurrency.
   */
  #addCurrentClientValue() {
    const kycStatus = this.#accounts[0].kycMailingStatus || 'Standard';
    for (const feeGroup of this.#customer.feeGroups) {
      for (const field of feeGroup.fields) {
        if (
          feeGroup.name === "Client Current Fees" &&
          kycStatus === "Standard" &&
          field.code === 2
        ) {
          field.defaultValue = "NOT APPLICABLE";
          field.labelValue = "NOT APPLICABLE";
        } else if (
          feeGroup.name === "Exception Request" &&
          field.code === 1 &&
          !field.hasChanged
        ) {
          // Para o campo Account Maintenance no grupo Exception Request,
          // se não houve alteração, o valor deve ficar vazio.
          field.defaultValue = "";
          field.labelValue = "";
        } else {
          field.labelValue = numberToCurrency(field.defaultValue);
        }
      }
    }
  }

  get fee() {
    return this.#customer;
  }
}
