"use client";
import React, { useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/Tabs";
import CreationContent from "./content/CreationContent";
import ValidationContent from "./content/ValidationsContent";
import { Documents } from "@/components/Documents";
import { useAuthStore } from "@/app/store/auth/authStore";
import { useDocumentStore } from "@/app/store/documentsStore/documentStore";
import { Document } from "@/app/store/types";
import RequestConfigProvider from "@/app/providers/getRequestProvider";
import { TabsNavigation } from "@/components/TabsNavigation";
import InstructionEmail from "@/components/InstructionEmail";
import { Approvals } from "@/components/Approvals";
import Requests from "@/components/Requests";
import History from "@/components/history/History";
import { toHistoryData } from "@/app/utils/toHistoryData";
import { parseHistoryToData } from "@/app/utils/parseHistoryToData";

type IPageTabsParams = {
  params: {
    requestName: string;
    requestId?: string;
  };
  tabTriggerType: string;
};

export default function PageTabs({ params, tabTriggerType }: IPageTabsParams) {
  const { getRequestConfig } = RequestConfigProvider(params.requestId);
  const { userData } = useAuthStore((state) => state);
  const { documentList, setDocumentList } = useDocumentStore((state) => state);
  const { isLoading, isFetching, data } = getRequestConfig;

  // Exemplo de uso:

  
  const mockJson = parseHistoryToData(getRequestConfig);

  
  console.log('>>>>>>>>>>>>',JSON.stringify(mockJson, null, 2));

  const validationStatus = data?.timeline
    ?.flat()
    ?.find((item: any) => item?.name?.includes("Validation"));

  useEffect(() => {
    setDocumentList([]);

    return () => {
      setDocumentList([]);
    };
  }, []);

  if (!data) {
    return;
  }

  const historyData = toHistoryData(data);

  console.log('historyData', historyData)

  return (
    <Tabs
      defaultValue={tabTriggerType}
      className="min-h-screen w-full py-7 px-6"
    >
      <TabsList>
        <TabsTrigger
          value="request"
          className="-mb-1 rounded-t-lg font-figtree flex h-[45px] cursor-pointer flex-row items-center justify-center bg-background-primary text-sm font-normal text-[#636574] aria-selected:!bg-white aria-selected:text-[#1e2347]"
        >
          {data.caseNumber ? (
            <>{`Request: ${data.caseNumber}`}</>
          ) : (
            "New Request"
          )}
        </TabsTrigger>
        <TabsTrigger
          value="documents"
          className="-mb-1 rounded-t-lg font-figtree flex h-[45px] cursor-pointer flex-row items-center justify-center bg-background-primary text-sm font-normal text-[#636574] aria-selected:!bg-white aria-selected:text-[#1e2347]"
        >
          Documents
        </TabsTrigger>
        <TabsTrigger
          value="history"
          className="-mb-1 rounded-t-lg font-figtree flex h-[45px] cursor-pointer flex-row items-center justify-center bg-background-primary text-sm font-normal text-[#636574] aria-selected:!bg-white aria-selected:text-[#1e2347]"
        >
          History
        </TabsTrigger>
      </TabsList>

      <TabsContent value="request">
        {validationStatus.status === "pending" ? (
          <Requests data={data} />
        ) : (
          <div className="w-full ">
            <TabsNavigation
              tabs={[
                {
                  label: "Creation",
                  content: <CreationContent data={data} />,
                },
                {
                  label: "Validations",
                  content: <ValidationContent />,
                } /*,
                // {
                //   label: "Acceptance",
                //   content: <AcceptanceContent />,
                // },
                // {
                //   label: "Callback",
                //   content: <CallbackContent />,
                // },*/,
              ]}
              initialTab={0}
            />
          </div>
        )}
      </TabsContent>

      <TabsContent
        value="documents"
        className="mt-0 rounded-b-lg rounded-r-lg bg-[white] aria-selected:block rounded-lg p-6"
      >
        {
          <Documents
            baseUrl={process.env.NEXT_PUBLIC_BASE_URL ?? ""}
            bucketName="conductor-client"
            pathUrl="/v1/file"
            getListDocument={documentList ?? []}
            showUploader={true}
            userData={userData}
            onUploadDocuments={(documents: Document[]) =>
              setDocumentList(documents)
            }
          />
        }
      </TabsContent>
      <TabsContent
        value="history"
        className="mt-0 rounded-b-lg rounded-r-lg bg-white p-6"
      >
        <History
          status={historyData.status}
          data={historyData.data}
          cardRowData={historyData.cardRowData}
          dataDisplayData={historyData.dataDisplayData}
          selectedBank={historyData.selectedBank}
        />
      </TabsContent>

      <TabsContent value="history">{<p>History</p>}</TabsContent>
    </Tabs>
  );
}



import { HistoryData } from "@/app/store/types";

export function toHistoryData(api: any): HistoryData {
  return {
    status: api.caseStatus,                         
    data: api.workflow ?? [],                       
    cardRowData: api.workflowApprovers ?? [],       
    dataDisplayData: (api.actions ?? []).map((a: any) => ({
      Id: a.stepName,
      Status: `${a.type}${a.subtype ? `: ${a.subtype}` : ""}`,
      Date: a.date,
    })),
    selectedBank: api.beneficiaryBankName?.content ?? "",
  };
}


export  function parseHistoryToData(history) {
    // Função para agrupar approvals
function groupApprovals(steps) {
      // Seleciona todos steps "Approvals and Restrictions:"
      const approvalSteps = steps.filter(step =>
        step.name && step.name.startsWith('Approvals and Restrictions')
      );
      // Para cada pessoa que deveria aprovar, pega os dados (mock espera um array de people)
      const people = [];
      approvalSteps.forEach(step => {
        if (step.permissions?.people && Array.isArray(step.permissions.people)) {
          step.permissions.people.forEach(person => {
            // No mock cada pessoa pode ter action como array, garantir isso
            people.push({
              ...person,
              // Aqui você pode adaptar os campos se quiser, ex:
              action: person.action || [],
            });
          });
        }
      });
      // Status geral: pending se algum pending, senão waiting/canceled/etc
      const status =
        approvalSteps.find(s => s.status === 'pending')?.status ||
        approvalSteps[0]?.status ||
        'pending';
      return {
        id: 3,
        name: "Approvals and Restrictions",
        status,
        successLabel: "Approved",
        permissions: {
          people
        }
      };
    }
  
    // Função para transformar um step "simples"
    function mapStep(step, mockData) {
      return {
        id: step.id,
        name: step.name,
        status: step.status,
        successLabel: step.successLabel || '',
        permissions: {
          people: (step.permissions?.people || []).map(p => ({
            ...p,
            action: p.action || [],
          }))
        }
      };
    }
  
    // 1. Transforma steps em formato mock
    const mockData = [];
  
    // 2. "Initiator"
    const initiatorStep = (Array.isArray(history.data) ? history.data.flat() : []).find(s => s.name?.toLowerCase().includes("initiator"));
    if (initiatorStep) {
      mockData.push(mapStep(initiatorStep));
    }
  
    // 3. "Validations" ou "Validation"
    const validationStep = (Array.isArray(history.data) ? history.data.flat() : []).find(s => s.name?.toLowerCase().includes("validation"));
    if (validationStep) {
      mockData.push({
        ...mapStep(validationStep),
        name: "Validations" // Normaliza nome
      });
    }
  
    // 4. "Approvals and Restrictions" agrupado
    mockData.push(groupApprovals((Array.isArray(history.data) ? history.data.flat() : [])));
  
    // 5. Restriction Removal
    const restrictionRemovalStep = (Array.isArray(history.data) ? history.data.flat() : []).find(s => s.name?.toLowerCase().includes("restriction removal"));
    if (restrictionRemovalStep) {
      mockData.push(mapStep(restrictionRemovalStep));
    }
  
    // 6. "Wire Repair"
    const wireRepairStep = (Array.isArray(history.data) ? history.data.flat() : []).find(s => s.name?.toLowerCase().includes("wire repair"));
    if (wireRepairStep) {
      mockData.push(mapStep(wireRepairStep));
    }
  
    // 7. "OFAC"
    const ofacStep = (Array.isArray(history.data) ? history.data.flat() : []).find(s => s.name?.toLowerCase().includes("ofac"));
    if (ofacStep) {
      mockData.push(mapStep(ofacStep));
    }
  
    // 8. "Processing"
    const processingStep = (Array.isArray(history.data) ? history.data.flat() : []).find(s => s.name?.toLowerCase().includes("processing"));
    if (processingStep) {
      mockData.push(mapStep(processingStep));
    }
  
    // 9. "Initiator Notified"
    const notifiedStep = (Array.isArray(history.data) ? history.data.flat() : []).find(s => s.name?.toLowerCase().includes("initiator notified"));
    if (notifiedStep) {
      mockData.push(mapStep(notifiedStep));
    }
  
    // --- cardRowData e dataDisplayData, selectedBank
    // Apenas replica do original (pode customizar se quiser)
    return {
      status: history.status,
      data: mockData.map(item => [item]), // cada step como array (igual seu mock)
      cardRowData: history.cardRowData,
      dataDisplayData: history.dataDisplayData,
      selectedBank: history.selectedBank,
    };
  }
  



