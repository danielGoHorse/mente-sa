import { Fee } from '#src/models/entities/Fees.js';
import Result from '#features/shared/result.js';
import CustomerFees from '#src/models/CustomerFees.js';
import BankAccountFee from '#src/models/BankAccountFee.js';
import InvestimentAccountFee from '#src/models/InvestimentAccountFee.js';
import { FeeCase } from '#src/models/entities/FeeCase.js';
import { connectToFeeMgmtDb, executeStoreProcedure } from '#core/data/mssql/index.js';

const deParaFeeCodes = {
  JH001: 1,
  JH002: 2,
  JH006: 4,
  JH007: 8,
  BPS002: 6,
  BPS003: 5,
  BPS004: 7,
  BPS005: 7,
  JH010: 3,
};

const deParaFeePackageId = {
  1: 'intlPB3',
  2: 'uSPBIndividual3',
  3: 'uSPBCorporation3',
  4: 'efraPB3',
  5: 'eraPB3',
};

const excludedCodes = new Set([8]);

export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    const result = { fees: [] };

    const { groupedFees, accounts, feePackageId } = await this.#getFeesStructuredFromSQL(customerAccount);

    result.accounts = accounts.map((account) => ({
      cifno: account.cifno,
      ddaNumber: account.ddaNumber,
      branchCity: account.branchCity,
      branchState: account.branchState,
      branchType: account.branchType,
      defaultPackageType: account.defaultPackageType,
      feePackage: account.feePackage,
      documentUrl: global.environment.scheduleUrls[deParaFeePackageId[feePackageId]] || null,
    }));

    const customer = new CustomerFees(groupedFees, accounts);
    if (customer.fee) result.fees.push(customer.fee);

    const bank = new BankAccountFee(groupedFees, accounts);
    if (bank.fee) result.fees.push(bank.fee);

    let investmentGroup = groupedFees['Investment Account Fees'];
    if (investmentGroup) {
      const equityFields = accounts.filter((account) => account.feeType === 3);
      equityFields.forEach((field) => {
        let investmentGroupFields = investmentGroup.feeGroups.find((group) => group.name === 'Standard Fees');
        if (!investmentGroupFields) {
          investmentGroupFields = {
            name: 'Standard Fees',
            code: 1,
            fields: [],
          };
          investmentGroup.feeGroups.push(investmentGroupFields);
        }

        investmentGroupFields.fields.push({
          code: field.code,
          name: field.name || 'Equity and Options Commission',
          defaultValue: field.defaultValue || '',
          tooltip: field.tooltip || '',
          isException: field.isException || false,
        });
      });

      result.fees.push(investmentGroup);
    }

    const feesActives = await FeeCase.find({
      cif: customerAccount[0].cifno,
      status: {
        $nin: ['DONE', 'REJECTED'],
      },
      caseNumber: {
        $exists: true,
      },
    });

    result.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id,
    }));

    return Result.ok(result);
  }

  async #getFeesStructuredFromSQL(customerAccount) {
    const feesData = await this.#getFeesFromSQL(customerAccount[0].cifno);

    const feePackageId = feesData[0]?.['Default Fee Package Id'];
    if (!feePackageId) {
      throw new Error('Default Fee Package Id not found in feesData');
    }

    const accounts = feesData.map((fee) => ({
      cifno: fee.CIFNO,
      ddaNumber: fee.ACCTNO,
      branchCity: fee['Branch City'],
      branchState: fee['Branch State'],
      branchType: fee['Branch Type'],
      defaultPackageType: fee['Default Package Type'],
      feePackage: fee['Default Fee Package']?.trim() || '',
      defaultFeePackageId: fee['Default Fee Package Id'] || '',
      feeType: this.#mapFeeType(fee.FeeType),
      feeGroup: 1,
      kycMailingStatus: fee.StandardException === 'Standard' ? 'Standard' : 'Hold Mail',
    }));

    const groupedFees = {};

    for (const fee of feesData) {
      const {
        FeeType,
        FeeDescription,
        FeeCode,
        FeeAmount,
        Frequency,
        DefaultFeeAmount,
        DefaultFrequency,
      } = fee;

      const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;

      if (
        (FeeType === 'Customer Fees' && ![1, 2].includes(mappedCode)) ||
        (FeeType === 'Bank Account Fees' && ![3, 4].includes(mappedCode)) ||
        (FeeType === 'Investment Account Fees' && ![5, 6, 7].includes(mappedCode)) ||
        excludedCodes.has(mappedCode)
      ) {
        continue;
      }

      if (!groupedFees[FeeType]) {
        groupedFees[FeeType] = {
          feeType: FeeType,
          feeGroups: [],
        };
      }

      let standardGroup = groupedFees[FeeType].feeGroups.find((group) => group.name === 'Standard Fees');
      if (!standardGroup) {
        standardGroup = {
          name: 'Standard Fees',
          code: 1,
          fields: [],
        };
        groupedFees[FeeType].feeGroups.push(standardGroup);
      }

      standardGroup.fields.push({
        code: mappedCode,
        name: FeeDescription,
        defaultValue: FeeAmount ? FeeAmount.toString() : '',
        tooltip: Frequency ? Frequency : '',
        isException: false,
      });
    }

    const exceptions = await this.#getExceptionFeesFromSQL(feePackageId);

    for (const exception of exceptions) {
      const { FeeCode, FeeDescription, FeeParameterOptionId, Amount } = exception;

      const feeType = Object.keys(groupedFees).find((type) =>
        groupedFees[type].feeGroups.some((group) =>
          group.fields.some((field) => field.code === deParaFeeCodes[FeeCode] || FeeCode)
        )
      );

      if (!feeType) {
        console.warn(`FeeType not found for exception code: ${FeeCode}`);
        continue;
      }

      let exceptionGroup = groupedFees[feeType]?.feeGroups.find(
        (group) => group.name === 'Exceptions Request'
      );

      if (!exceptionGroup) {
        exceptionGroup = {
          name: 'Exceptions Request',
          code: 3,
          fields: [],
        };
        groupedFees[feeType]?.feeGroups.push(exceptionGroup);
      }

      let existingField = exceptionGroup.fields.find((field) => field.code === (deParaFeeCodes[FeeCode] || FeeCode));

      if (!existingField) {
        existingField = {
          code: deParaFeeCodes[FeeCode] || FeeCode,
          name: FeeDescription,
          defaultValue: '',
          tooltip: '',
          isException: true,
          exceptionOptions: [],
        };
        exceptionGroup.fields.push(existingField);
      }

      existingField.exceptionOptions.push({
        value: Amount.toString(),
        text: `$${parseFloat(Amount).toFixed(2)}`,
        retired: false,
        visible: true,
        approvedByDoubleA: null,
        _id: FeeParameterOptionId,
      });
    }

    return { groupedFees: Object.values(groupedFees), accounts, feePackageId };
  }

  async #getFeesFromSQL(cifno) {
    const connection = await connectToFeeMgmtDb();
    return executeStoreProcedure(connection, 'sp_get_fees_byCIF', { cifno });
  }

  async #getExceptionFeesFromSQL(feePackageId) {
    const connection = await connectToFeeMgmtDb();
    return executeStoreProcedure(connection, 'sp_get_exception_fees_bypackage', { feePackageId });
  }
}
