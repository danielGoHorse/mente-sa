import { FeeGroup } from './entities/FeeGroups.js'
import numberToCurrency from '../core/helpers/currency.js'

export default class BankAccountFee {
  #feeName = 'Bank Account Fees'
  #bank = {}
  #accounts = []
  #accountsDDA = []
  constructor(fees, accounts) {
  // global.logger.info('BankAccountFee()')

    this.#bank = fees.filter((x) => x.feeType === this.#feeName)[0]
    const feeGroupCode = this.#bank.feeGroups[0].code

    this.#accounts = accounts.filter(
      (x) => x.feeGroup === this.#bank.feeGroups[0].code
    )

    this.#accountsDDA = new Set(
      accounts
        .filter((x) => x.feeGroup === feeGroupCode)
        .map((x) => x.ddaNumber)
    )

    this.#addMultiplesAccount(this.#accounts[0].cifno)
    this.#addCurrentClientValue()
  }

  get fee() {
    return this.#bank
  }

  #addMultiplesAccount(cif) {
  // global.logger.info('addMultiplesAccount()')

    if (this.#accounts && this.#accounts.length < 1) {
      this.#bank = {}
    }
    const result = {}
    for (const feeGroup of this.#bank.feeGroups) {
      for (const numberAccount of this.#accountsDDA) {
        if (!result[numberAccount]) result[numberAccount] = []

        feeGroup.fields?.forEach((item) => {
          item.exceptionOptions = item.exceptionOptions.filter(
            (x) => !x.retired
          )
        })

        const newFeeGroup = new FeeGroup({
          name: feeGroup.name,
          fields: feeGroup.fields,
          cif,
          accountNumber: numberAccount,
          visible: feeGroup.visible,
          code: feeGroup.code
        })

        result[numberAccount].push(newFeeGroup)
      }
    }
    const feeGroupsByAccount = Object.keys(result).map((item) => result[item])
    this.#bank.feeGroups = []
    for (const feeGroups of feeGroupsByAccount) {
      for (const feeGroup of feeGroups) {
        this.#bank.feeGroups.push(feeGroup)
      }
    }
  }

  #addCurrentClientValue() {
  // global.logger.info('addCurrentClientValue()')

    if (this.#accounts && this.#accounts.length < 1) {
      this.#bank = {}
      return
    }

    for (const [feeGroupIndex, feeGroup] of this.#bank.feeGroups.entries()) {
      feeGroup.cif = this.#accounts[0].cifno
      for (const [fieldIndex, field] of feeGroup.fields.entries()) {
        if (field.isException) {
          field.labelValue =
            this.#bank.feeGroups[feeGroupIndex - 1].fields[
              fieldIndex
            ].labelValue
        } else {
          for (const account of this.#accounts) {
            if (
              field.code === account.feeType &&
              feeGroup.accountNumber === account.ddaNumber.toString()
            ) {
              if (field.isCurrentClient) {
                field.defaultValue = account.feeAmount.toString()
              }
              field.labelValue = numberToCurrency(field.defaultValue)
            }
          }
        }
      }
    }

    this.#clearMemory()
  }

  #clearMemory() {
    this.#accounts = []
    this.#accountsDDA = []
  }
}



import { FeeGroup } from './entities/FeeGroups.js'
import numberToCurrency from '../core/helpers/currency.js'

export default class InvestimentAccountFee {
  #feeName = 'Investment Account Fees'
  #investiment = {}
  #accounts = []
  #accountsDDA = []
  #allExceptions = new Set()
  constructor(fees, accounts, equityField) {
    this.#investiment = fees.filter((x) => x.feeType === this.#feeName)[0]
    const feeGroupCode = this.#investiment.feeGroups[0].code

    this.#accounts = accounts.filter(
      (x) => x.feeGroup === this.#investiment.feeGroups[0].code
    )

    if (this.#accounts && this.#accounts.length < 1) {
      this.#investiment = {}
      return
    }

    this.#accountsDDA = new Set(
      accounts
        .filter((x) => x.feeGroup === feeGroupCode && x.bpsFeeTypeCode !== 'O')
        .map((x) => ({
          number: x.bpsAcctNumber,
          code: x.feeType,
          entity: x.entity
        }))
    )

    this.#addMultiplesAccount(this.#accounts[0].cifno)
    this.#addCurrentClientValue(equityField)
  }

  get fee() {
    return this.#investiment
  }

  #addMultiplesAccount(cif) {
    const result = {}

    for (const feeGroup of this.#investiment.feeGroups) {
      for (const account of this.#accountsDDA) {
        if (!result[account.number]) {
          result[account.number] = {}
        }

        const fields = feeGroup.fields.filter((x) => x.code === account.code)

        if (fields.length === 0) continue

        if (!result[account.number][feeGroup.name]) {
          result[account.number][feeGroup.name] = []

          feeGroup.fields?.forEach((item) => {
            item.exceptionOptions.forEach(
              this.#allExceptions.add,
              this.#allExceptions
            )
            item.exceptionOptions = item.exceptionOptions.filter(
              (x) => !x.retired
            )
          })

          const newFeeGroup = new FeeGroup({
            name: feeGroup.name,
            fields,
            cif,
            accountNumber: account.number,
            visible: feeGroup.visible,
            code: feeGroup.code,
            entityCode: account.entity
          })
          result[account.number][feeGroup.name].push(newFeeGroup)
          continue
        }

        const feeGroupToAddFields = result[account.number][feeGroup.name][0]
        feeGroupToAddFields.fields = [...feeGroupToAddFields.fields, ...fields]
      }
    }

    const feeGroupsByAccount = Object.keys(result).reduce((acc, item) => {
      Object.keys(result[item]).forEach((element) => {
        acc.push(result[item][element])
      })
      return acc
    }, [])
    this.#investiment.feeGroups = []
    for (const feeGroups of feeGroupsByAccount) {
      for (const feeGroup of feeGroups) {
        this.#investiment.feeGroups.push(feeGroup)
      }
    }
  }

  #addCurrentClientValue(equityField) {
    const exceptionsOptions = Array.from(this.#allExceptions)
    for (const [
      feeGroupIndex,
      feeGroup
    ] of this.#investiment.feeGroups.entries()) {
      feeGroup.cif = this.#accounts[0].cifno
      for (const [fieldIndex, field] of feeGroup.fields.entries()) {
        if (field.isException) {
          field.labelValue =
            this.#investiment.feeGroups[feeGroupIndex - 1].fields[
              fieldIndex
            ].labelValue
        } else {
          for (const account of this.#accounts) {
            if (
              field.code === account.feeType &&
              feeGroup.accountNumber === account.bpsAcctNumber
            ) {
              if (field.code === 5) {
                field.defaultValue = field.isStandard
                  ? field.defaultValue
                  : account.feeAmount.toString()
                field.labelValue = numberToCurrency(field.defaultValue)
              } else {
                if (field.labelValue !== 'Other') {
                  if (field.isCurrentClient) {
                    field.defaultValue = account.feeCode.toString()
                  }

                  let exception = exceptionsOptions.find(
                    (x) => x.value === field.defaultValue
                  )

                  if (!exception) {
                    exception = equityField.exceptionOptions.filter(
                      (e) => e.value === field.defaultValue
                    )[0]

                    if (!exception) {
                      exception = { text: '' }
                    }
                  }

                  field.labelValue = exception.text
                }
              }
            }
          }
        }
      }
    }

    this.#clearMemory()
  }

  #clearMemory() {
    this.#accounts = []
    this.#accountsDDA = []
    this.#allExceptions = new Set()
  }
}
