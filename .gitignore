const exceptions = await this.#getExceptionFeesFromSQL(feePackageId);

for (const exception of exceptions) {
    const { FeeType, FeeCode, FeeDescription, FeeParameterOptionId, Amount, FreqDescription } = exception;

    // Mapear o código corretamente
    const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;

    // Excluir código 8 das exceptions também
    if (excludedCodes.has(mappedCode)) {
        continue;
    }

    // Se o FeeType não existir ainda, cria a estrutura correta
    if (!groupedFees[FeeType]) {
        groupedFees[FeeType] = {
            feeType: FeeType,
            feeGroups: [],
        };
    }

    // Buscar ou criar o grupo Exceptions Request
    let exceptionGroup = groupedFees[FeeType]?.feeGroups.find(
        (group) => group.name === 'Exceptions Request'
    );

    if (!exceptionGroup) {
        exceptionGroup = {
            name: 'Exceptions Request',
            code: 3,
            fields: [],
        };
        groupedFees[FeeType]?.feeGroups.push(exceptionGroup);
    }

    // Buscar ou criar o campo correspondente dentro de Exceptions Request
    let existingField = exceptionGroup.fields.find(field => field.code === mappedCode);

    if (!existingField) {
        existingField = {
            code: mappedCode,
            name: FeeDescription,
            defaultValue: Amount, // Mantendo o valor direto do banco
            tooltip: FreqDescription || '',
            isException: true,
            exceptionOptions: []
        };
        exceptionGroup.fields.push(existingField);
    }

    // Adicionar as opções dentro do exceptionOptions do campo correto
    existingField.exceptionOptions.push({
        value: Amount,
        text: `$${parseFloat(Amount).toFixed(2)}`,
        retired: false,
        visible: true,
        approvedByDoubleA: null,
        _id: FeeParameterOptionId, 
    });
}

// **Retornar todos os grupos no formato correto**
return { groupedFees: Object.values(groupedFees), accounts };
