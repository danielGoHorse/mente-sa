import Result from '#features/shared/result.js'
import { FeeCase } from '#src/models/entities/FeeCase.js'

function formatMessage(result, userNameFull, updatedAt) {
  return `${result} by ${userNameFull} on ${new Date(
    updatedAt
  ).toLocaleDateString('en-US')}`
}

function findApprover(field, approver) {
  global.logger.info('findApprover()')

  const result = field.results.get(approver.userName.toUpperCase())

  if (!result) return null

  const message = formatMessage(
    result,
    approver.userNameFull,
    approver.updatedAt
  )

  return {
    message,
    approved: result === 'Approved',
    note: field.rejectComment
  }
}

function processCommonApprover(feeCase, feeGroup, commonApprover) {
  global.logger.info('processCommonApprover()')
  const approvers = []

  const field = feeGroup.fields.find(
    (field) => field.hasChanged && (field.approved || field.reject)
  )

  if (!field) return approvers

  if (!field.results) {
    field.results = {}
  } else {
    const commonApproverResult = findApprover(field, commonApprover)
    if (commonApproverResult) approvers.push(commonApproverResult)

    const equityApprover = feeCase.equityTeam.find((user) => user.result)
    if (equityApprover) {
      const equityField = feeGroup.fields.find(
        (field) =>
          field.results &&
          !!field.results.get(equityApprover.userName.toUpperCase())
      )

      if (equityField) {
        const equityApproverResult = findApprover(equityField, equityApprover)
        if (equityApproverResult) approvers.push(equityApproverResult)

        equityField.results = Object.fromEntries(field.results)
      }
    }
    if (field.results instanceof Map) {
      field.results = Object.fromEntries(field.results)
    }
  }

  return approvers
}

function resetLastFieldBasedOnConditions(lastField, lastOption, feeCase) {
  if (
    lastOption.text === 'Other' &&
    lastOption.value !== '' &&
    feeCase.status === 'PENDING_EQUITY' &&
    lastField.approved
  ) {
    delete lastField.approved
    delete lastField.reject
    delete lastField.rejectComment
  }
}

export default class FeeCaseGetByIdAndUserNameUseCase {
  async execute({ feeId, userName }) {
    global.logger.info(`FeeCaseGetByIdAndUserNameUseCase(fee=${feeId}, userName=${userName})`)

    const strategyForStatus = {
      INITIAL: 'usersApprovers',
      PENDING_APPROVAL: 'usersApprovers',
      PENDING_EQUITY: 'equityTeam',
      PENDING_SECOPS: 'secopsTeam',
      VISIBLE_ONLY: 'visibleToUsers'
    }
    const strategyForApprover = {
      INITIAL: 'canApprove',
      PENDING_APPROVAL: 'canApprove',
      PENDING_EQUITY: 'canEditEquity',
      PENDING_SECOPS: 'canEditSecops'
    }

    const hasFee = await FeeCase.exists({ _id: feeId })

    if (!hasFee) {
      return Result.fail('Fee case not found')
    }

    const feeCase = await (await FeeCase.findById(feeId)).toObject()
    feeCase.documentUrl =
      'https://minio-ui.dev.k8s.safra.int/api/v1/buckets/jarvis-public/objects/download?preview=true&prefix=U2NoZWR1bGVPZkZlZXMucGRm'

    const feesActives = await FeeCase.find({
      cif: feeCase.cif,
      status: {
        $nin: ['DONE', 'REJECTED']
      },
      caseNumber: {
        $exists: true
      }
    })

    feeCase.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id
    }))

    if (!['INITIAL', 'PENDING_APPROVAL'].includes(feeCase.status)) {
      feeCase.fees.forEach((fee) => {
        fee.feeGroups.forEach((feeGroup) => {
          if (feeGroup.name !== 'Exception Request') return

          const lastField = feeGroup.fields.slice(-1)[0]
          const lastOption = lastField.exceptionOptions.slice(-1)[0]

          const commonApprover = feeCase.usersApprovers.find(
            (user) => user.result
          )
          if (commonApprover) {
            feeGroup.approvalResults = processCommonApprover(
              feeCase,
              feeGroup,
              commonApprover
            )
          }

          resetLastFieldBasedOnConditions(lastField, lastOption, feeCase)
        })
      })
    }

    if (feeCase?.userOwner?.toUpperCase() === userName?.toUpperCase()) {
      feeCase.canApprove = false
      return Result.ok(feeCase)
    }

    const userListProperty = strategyForStatus[feeCase.status]
    const canApproveProperty = strategyForApprover[feeCase.status]

    if (
      feeCase[userListProperty] &&
      feeCase[userListProperty].some(
        (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
      )
    ) {
      feeCase[canApproveProperty] = true

      if (
        feeCase.status === 'PENDING_APPROVAL' &&
        feeCase[userListProperty]
          .filter(
            (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
          )[0]
          ?.signature.includes('AAA')
      ) {
        feeCase.canSeeRevenueReport = true
      }

      return Result.ok(feeCase)
    }

    const propertys = Object.keys(strategyForStatus)
    let canSeeCase = false
    for (const property of propertys) {
      const userProperty = strategyForStatus[property]
      if (
        feeCase[userProperty].some(
          (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
        )
      ) {
        canSeeCase = true
        break
      }
    }

    if (canSeeCase) {
      return Result.ok(feeCase)
    }

    return Result.fail('Not found')
  }
}
