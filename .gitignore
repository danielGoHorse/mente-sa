for (const exception of exceptions) {
    const { FeeType, FeeCode, FeeDescription, FeeParameterOptionId, Amount, FreqDescription } = exception;
    
    // Mapear o código corretamente
    const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;

    // Excluir código 8 das exceptions também
    if (excludedCodes.has(mappedCode)) {
        continue;
    }

    // Garantir que o feeType correto seja usado
    if (!groupedFees[FeeType]) {
        groupedFees[FeeType] = {
            feeType: FeeType,
            feeGroups: [],
        };
    }

    let exceptionGroup = groupedFees[FeeType]?.feeGroups.find(
        (group) => group.name === 'Exceptions Request'
    );

    if (!exceptionGroup) {
        exceptionGroup = {
            name: 'Exceptions Request',
            code: 3,
            fields: [],
        };
        groupedFees[FeeType]?.feeGroups.push(exceptionGroup);
    }

    let existingField = exceptionGroup.fields.find(field => field.code === mappedCode);

    if (!existingField) {
        existingField = {
            code: mappedCode,
            name: FeeDescription,
            defaultValue: Amount ? Amount.toString() : '0', // Valor correto do Amount
            tooltip: FreqDescription || '',
            isException: true,
            exceptionOptions: []
        };
        exceptionGroup.fields.push(existingField);
    }

    // Adicionar as exceptions dentro do campo correspondente
    existingField.exceptionOptions.push({
        value: Amount.toString(),
        text: `$${parseFloat(Amount).toFixed(2)}`,
        retired: false,
        visible: true,
        approvedByDoubleA: null,
        _id: FeeParameterOptionId, 
    });
}
