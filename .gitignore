import Result from '#features/shared/result.js';

export default class FeeCaseGetByCifUseCase {
  async execute({ cif }, feeManagementModel, customerModel) {
    const [errCustomer, responseCustomer] = await customerModel.getCustomerDetailsByCif(cif);
    if (errCustomer) {
      return Result.fail({ message: "It's not possible to get address cif" });
    }

    const customerData = responseCustomer?.data?.customer || {};
    const [errFee, responseFee] = await feeManagementModel.getFeeByAccount(customerData);
    if (errFee) {
      return Result.fail({ message: "It's not possible to get fee values" });
    }

    /**
     * Função para garantir que cada `field` terá sempre
     * as mesmas propriedades, com valores default caso não existam.
     */
    function unifyFieldShape(field) {
      return {
        code: field.code ?? "",
        name: field.name ?? "",
        defaultValue: field.defaultValue ?? "",
        labelValue: field.labelValue ?? "",
        isException: field.isException ?? false,
        exceptionOptions: field.exceptionOptions ?? [],
        hasChanged: field.hasChanged ?? false,
        createdAt: field.createdAt ?? "",
        updatedAt: field.updatedAt ?? "",
        id: field.id ?? "",
        isStandard: field.isStandard ?? false,
        isCurrentClient: field.isCurrentClient ?? false,
        tooltip: field.tooltip ?? ""
      };
    }

    /**
     * Função para garantir que cada `feeGroup` tenha sempre
     * `name`, `accountNumber`, `cif`, `kycMailingStatus`, `fields`.
     */
    function unifyFeeGroupShape(group) {
      return {
        name: group.name ?? "",
        accountNumber: group.accountNumber ?? "",
        cif: group.cif ?? "",
        kycMailingStatus: group.kycMailingStatus ?? "",
        fields: Array.isArray(group.fields)
          ? group.fields.map(unifyFieldShape)
          : []
      };
    }

    /**
     * Se precisar normalizar nome de fee, use algo assim.
     * (Apenas se estiver precisando transformar algo como "HoldMailFee" em "Hold Mail Fee").
     */
    function normalizeFeeName(text = "") {
      return text
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/[_-]/g, ' ')
        .trim();
    }

    const feesData = responseFee?.data || {};
    const timestamp = new Date().toISOString();

    // Só exemplos de "info" - ajuste conforme sua fonte
    const packageName = feesData.feePackage || "N/A";
    const packageType = feesData.defaultPackageType || "N/A";
    const branchType = feesData.branchType || "N/A";

    // Monta currentFees caso precise
    const currentFees = [
      ...(customerData?.customerCurrentFees?.map(x => ({
        feeDescription: x.feeDescription || '',
        feeCode: x.feeCode || ''
      })) || []),
      ...(feesData?.currentFees || [])
    ];

    // Mapa FeeType (caso você use)
    const feeTypeMap = {
      1: "Customer Fees",
      2: "Bank Account Fees",
      3: "Investment Account Fees"
    };

    // ### 1) MONTA OS feeGroups DO LADO "CUSTOMER" (customerData)
    //    (Caso você precise, senão pode remover.)
    const rawCustomerAccounts = customerData?.customerAccount || [];
    const filteredCustomerAccounts = rawCustomerAccounts.filter(acc => {
      const feeTypeString = feeTypeMap[acc.feeType] || "";
      return ["Customer Fees","Bank Account Fees","Investment Account Fees"].includes(feeTypeString);
    });

    // Exemplo: transformar cada account do cliente em:
    // {
    //   feeType: "Bank Account Fees",
    //   feeGroups: [
    //     {
    //       name: "Standard Fees" ou "Client Current Fees", ...
    //       fields: [...]
    //     }
    //   ]
    // }
    const formattedFeesFromCustomer = filteredCustomerAccounts.map(acc => {
      const normalizedName = normalizeFeeName(acc.feeDescription);

      // Exemplo de field - ajuste se precisar
      const field = {
        code: acc.feeCode || "",
        name: normalizedName,
        defaultValue: acc.feeAmount?.toString() || "",
        labelValue: acc.feeAmount > 0 ? `$${acc.feeAmount.toFixed(2)}` : "",
        isException: acc.isFeesStandard === "No",
        exceptionOptions: [],
        hasChanged: false,
        createdAt: timestamp,
        updatedAt: timestamp,
        id: acc.ddaNumber?.toString() || "",
        isStandard: acc.isFeesStandard === "Yes",
        isCurrentClient: false,
        tooltip: acc.source ? `Source: ${acc.source}` : ""
      };

      return {
        feeType: feeTypeMap[acc.feeType] || "",
        feeGroups: [
          unifyFeeGroupShape({
            name: acc.feeGroup === 1 ? "Client Current Fees" : "Standard Fees",
            accountNumber: acc.ddaNumber?.toString() ?? "",
            cif: acc.cifno?.toString() ?? "",
            kycMailingStatus: acc.kycMailingStatus ?? "",
            fields: [ field ]
          })
        ]
      };
    });

    // ### 2) MONTA OS feeGroups VINDOS DO feeManagementModel (feesData)
    //     (Ou seja, do responseFee?.data?.fees)
    const formattedFeeGroupsFromData =
      feesData?.fees?.map(fg => ({
        feeType: fg.feeType || "",
        feeGroups: fg.feeGroups?.map(g => unifyFeeGroupShape(g)) || []
      })) || [];

    // ### 3) JUNTA OS DOIS ARRAYS
    const allFees = [...formattedFeesFromCustomer, ...formattedFeeGroupsFromData];

    // ### 4) Agrupa por feeType (por ex: "Customer Fees", "Bank Account Fees", "Investment Account Fees")
    // Se não precisar agrupar, basta passar `allFees` adiante. Mas, como no seu código,
    // você gera um array final com 3 objetos (um para cada feeType).
    const feeTypesToReturn = ["Customer Fees","Bank Account Fees","Investment Account Fees"];

    const groupedFees = feeTypesToReturn.map(type => {
      // Filtra quem tem feeType === type
      const itemsOfThisType = allFees.filter(item => item.feeType === type);

      // Junta todos os feeGroups num array só
      const combinedGroups = itemsOfThisType.flatMap(item => item.feeGroups || []);

      return {
        feeType: type,
        feeGroups: combinedGroups
      };
    });

    // ### 5) Monta o objeto final
    const result = {
      customerName: customerData?.customerAddress?.name || feesData?.customerName || '',
      customerShortName: feesData?.customerShortName || '',
      customerAddress: customerData?.customerAddress?.address || '',
      customerAccountOfficer: customerData?.customerAddress?.officer || '',
      cif: customerData?.customerAddress?.cif || cif,
      officerId: feesData?.officerId || '',
      branchCity: feesData?.branchCity || '',
      branchState: feesData?.branchState || '',
      branchType,
      feePackage: feesData?.feePackage || '',
      defaultFeePackageId: feesData?.defaultFeePackageId || '',
      defaultPackageType: feesData?.defaultPackageType || '',
      packageName,
      packageType,
      fees: groupedFees,           // <-- Aqui a lista final
      feesActives: feesData?.feesActives || [],
      documentUrl: feesData?.documentUrl || '',
      currentFees
    };

    global.logger.info('End process');

    // Retorna no formato: { code: 200, data: result }
    return {
      code: 200,
      data: result
    };
  }
}
