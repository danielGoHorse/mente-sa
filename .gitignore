import { FeeGroup } from './entities/FeeGroups.js';
import numberToCurrency from '../core/helpers/currency.js';

export default class CustomerFees {
  #feeName = 'Customer Fees';
  #customer = {};
  #accounts = [];

  constructor(fees, accounts) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }
    // Seleciona os dados do fee do tipo Customer Fees
    this.#customer = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (!this.#customer || !Array.isArray(this.#customer.feeGroups)) {
      throw new Error('Customer Fees or feeGroups are undefined');
    }
    if (!accounts || !Array.isArray(accounts) || accounts.length === 0) {
      throw new Error('Accounts is empty or undefined');
    }
    // Para Customer Fees, geralmente há apenas uma conta
    this.#accounts = [accounts[0]];

    

    this.#addMultiplesAccount(this.#accounts[0].cifno);
    this.#addCurrentClientValue();
  }

  /**
   * Função auxiliar para deduplicar os campos (fields) com base no fee code.
   *
   * @param {Array} fields - Array de fields a serem deduplicados.
   * @returns {Array} - Array de fields sem duplicação.
   */
  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  /**
   * Gera os feeGroups para a conta, clonando os grupos originais
   * e atribuindo o número da conta (accountNumber) e o kycMailingStatus.
   * Como para Customer Fees normalmente há apenas uma conta, não há replicação.
   *
   * @param {string} cif - O CIF do cliente.
   */
  #addMultiplesAccount(cif) {
    const feeGroupTemplates = this.#customer.feeGroups;
    const newFeeGroups = [];

    for (const template of feeGroupTemplates) {
      // Clona os fields para evitar referências compartilhadas
      let clonedFields = template.fields.map((field) => ({
        ...field,
        exceptionOptions: field.exceptionOptions
          ? field.exceptionOptions.map((opt) => ({ ...opt }))
          : []
      }));

      // Deduplica os fields com base no fee code
      clonedFields = this.#deduplicateFields(clonedFields);

      // Define o kycMailingStatus: utiliza o valor da conta, se existir, ou "Standard" como padrão.
      const kycMailingStatus =
        this.#accounts[0].kycMailingStatus || 'Print';

      const newFeeGroup = new FeeGroup({
        name: template.name,
        fields: clonedFields,
        cif,
        accountNumber: this.#accounts[0].ddaNumber.toString(),
        visible: template.visible,
        code: template.code,
        kycMailingStatus // Adicionado para garantir que não venha null
      });
      newFeeGroups.push(newFeeGroup);
    }

    this.#customer.feeGroups = newFeeGroups;
  }

  /**
   * Atualiza os valores dos fees para cada grupo, definindo o labelValue com base no valor.
   * Para Customer Fees, se o campo defaultValue já estiver definido (vindo do banco),
   * ele não é sobrescrito.
   */
  #addCurrentClientValue() {
    for (const feeGroup of this.#customer.feeGroups) {
      for (const field of feeGroup.fields) {
        field.labelValue = numberToCurrency(field.defaultValue);
      }
    }
  }

  get fee() {
    return this.#customer;
  }
}
