import Result from '#features/shared/result.js'
import numberToCurrency from '#core/helpers/currency.js'
import { FeeCase } from '#src/models/entities/FeeCase.js'
import { Field } from '#src/models/entities/Fields.js'
import { Fee } from '#src/models/entities/Fees.js'
const { logger } = global

export default class FeeCaseCreateUseCase {
  async execute(feeTicketRequest) {
    logger.info('FeeCaseCreateUseCase()')

    // 1) Cria uma instância do schema FeeCase a partir do payload
    const feeTicket = new FeeCase(feeTicketRequest)

    // 2) Busca dados "Fee Standard" (seu fallback de 3 feeTypes)
    const fieldsDataBase = await this.#getFeeStandard([
      { feeType: 'Customer Fees' },
      { feeType: 'Bank Account Fees' },
      { feeType: 'Investment Account Fees' }
    ])

    // 3) Retorna todas as exceptions disponíveis
    const allExceptions = this.#returnAllExceptions(fieldsDataBase)

    logger.info('validateSync()')
    const validate = feeTicket.validateSync()
    if (validate && validate?.errors) {
      return Result.fail(validate.errors)
    }

    let hasAnyChange = false
    // 4) Itera pelos fees do feeTicket para identificar campos "hasChanged"
    for (const fee of feeTicket.fees) {
      for (const [groupIndex, group] of fee.feeGroups.entries()) {
        for (const [fieldIndex, field] of group.fields.entries()) {
          if (field.isException) {
            // se for uma exception, verifica se é uma alteração
            const newValue =
              field.defaultValue !== fee.feeGroups[groupIndex - 1].fields[fieldIndex].defaultValue
            const validValue = !!field.defaultValue && field.defaultValue !== 'NOT APPLICABLE'
            field.hasChanged = newValue && validValue

            if (field.hasChanged) {
              hasAnyChange = true
              fee.hasAnyChange = true
              group.hasAnyChange = true
              // marca grupos anteriores (Standard / Client Current) como hasAnyChange para controlar no front
              fee.feeGroups[groupIndex - 1].hasAnyChange = true
              fee.feeGroups[groupIndex - 2].hasAnyChange = true
            }

            if (!field.hasChanged) {
              // se não houve mudança, a exception recebe o mesmo valor do "Client Current Fees"
              field.defaultValue = fee.feeGroups[groupIndex - 1].fields[fieldIndex].defaultValue
            }
          }

          // se o valor for apenas dígitos, converte em moeda
          if (/^\d+$/.test(field.defaultValue)) {
            field.labelValue = numberToCurrency(field.defaultValue)
            continue
          }

          // Lógica para equity safekeeping etc. (exemplo original)
          if (field.labelValue === 'Other') {
            const other = field.exceptionOptions.filter(x => x.text === 'Other')[0]
            const fieldEquities = (
              await Field.find({
                code: 7,
                isException: true
              })
            )[0]

            field.exceptionOptions = [...fieldEquities.exceptionOptions, other]
          }
          else if (!field.labelValue || !field.labelValue.includes(field.defaultValue)) {
            let exception = allExceptions.find(e => e.value === field.defaultValue)
            if (!exception) {
              exception = { text: '' }
            }
            field.labelValue = exception.text
          }
        }
      }
    }

    if (!hasAnyChange) {
      return Result.fail('Cannot create Fee Case without any change.')
    }

    // Filtra fees e feeGroups que realmente tiveram mudança
    feeTicket.fees = feeTicket.fees.filter(x => x.hasAnyChange)
    feeTicket.fees?.forEach(item => {
      item.feeGroups = item.feeGroups.filter(x => x.hasAnyChange)
    })

    try {
      // 5) Salva no banco
      const model = await feeTicket.save()
      // 6) Converte em objeto
      const resultObject = model.toObject()

      // 7) Aqui, injete os campos extras no payload final
      //    Ajuste para pegar do feeTicketRequest (ou outro local)
      // Exemplo:
      resultObject.branchCity = feeTicketRequest.branchCity
      resultObject.branchType = feeTicketRequest.branchType
      resultObject.defaultPackageType = feeTicketRequest.defaultPackageType
      resultObject.feePackage = feeTicketRequest.feePackage
      // Outras propriedades se desejar

      // retorna com os campos extras
      return Result.ok(resultObject)
    } catch (err) {
      logger.error(err)
      return Result.fail('Error when try to save Fee Case')
    }
  }

  async #getFeeStandard(filter) {
    logger.info('getFeeStandard()')
    const feeResult = []

    for await (const fee of Fee.find({
      $or: filter
    }).select({
      feeGroups: {
        fields: 1,
        code: 1
      }
    })) {
      feeResult.push(fee.toObject())
    }

    return feeResult
  }

  #returnAllExceptions(fees) {
    logger.info('returnAllExceptions()')
    const allExceptions = new Set()
    fees.forEach(fee => {
      fee.feeGroups.forEach(feeGroup => {
        feeGroup.fields.forEach(field => {
          if (field.isException) {
            field.exceptionOptions.forEach(allExceptions.add, allExceptions)
          }
        })
      })
    })
    return Array.from(allExceptions)
  }
}
