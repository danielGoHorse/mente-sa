import Result from '#features/shared/result.js'
import { FeeCase } from '#src/models/entities/FeeCase.js'

function formatMessage(result, userNameFull, updatedAt) {
  return `${result} by ${userNameFull} on ${new Date(
    updatedAt
  ).toLocaleDateString('en-US')}`
}

function findApprover(field, approver) {
  global.logger.info('findApprover()')
  const result = field.results.get(approver.userName.toUpperCase())
  if (!result) return null

  const message = formatMessage(result, approver.userNameFull, approver.updatedAt)
  return {
    message,
    approved: result === 'Approved',
    note: field.rejectComment
  }
}

function processCommonApprover(feeCase, feeGroup, commonApprover) {
  global.logger.info('processCommonApprover()')
  const approvers = []

  const field = feeGroup.fields.find(
    (field) => field.hasChanged && (field.approved || field.reject)
  )
  if (!field) return approvers

  if (!field.results) {
    field.results = {}
  } else {
    const commonApproverResult = findApprover(field, commonApprover)
    if (commonApproverResult) {
      approvers.push(commonApproverResult)
    }

    const equityApprover = feeCase.equityTeam.find((user) => user.result)
    if (equityApprover) {
      const equityField = feeGroup.fields.find(
        (f) =>
          f.results &&
          !!f.results.get(equityApprover.userName.toUpperCase())
      )

      if (equityField) {
        const equityApproverResult = findApprover(equityField, equityApprover)
        if (equityApproverResult) {
          approvers.push(equityApproverResult)
        }
        equityField.results = Object.fromEntries(field.results)
      }
    }

    if (field.results instanceof Map) {
      field.results = Object.fromEntries(field.results)
    }
  }

  return approvers
}

function resetLastFieldBasedOnConditions(lastField, lastOption, feeCase) {
  if (
    lastOption.text === 'Other' &&
    lastOption.value !== '' &&
    feeCase.status === 'PENDING_EQUITY' &&
    lastField.approved
  ) {
    delete lastField.approved
    delete lastField.reject
    delete lastField.rejectComment
  }
}

// Exemplo de função auxiliar que pega a URL do environment, caso queira
function getDocumentUrl() {
  // Ajuste o nome do bucket, prefix, etc., conforme sua config:
  return global.environment?.documentUrl || 
    'https://minio-ui.dev.k8s.safra.int/api/v1/buckets/jarvis-public/objects/download?preview=true&prefix=U2NoZWR1bGVPZkZlZXMucGRm'
}

export default class FeeCaseGetByIdAndUserNameUseCase {
  async execute({ feeId, userName }) {
    global.logger.info(`FeeCaseGetByIdAndUserNameUseCase(fee=${feeId}, userName=${userName})`)

    const strategyForStatus = {
      INITIAL: 'usersApprovers',
      PENDING_APPROVAL: 'usersApprovers',
      PENDING_EQUITY: 'equityTeam',
      PENDING_SECOPS: 'secopsTeam',
      VISIBLE_ONLY: 'visibleToUsers'
    }

    const strategyForApprover = {
      INITIAL: 'canApprove',
      PENDING_APPROVAL: 'canApprove',
      PENDING_EQUITY: 'canEditEquity',
      PENDING_SECOPS: 'canEditSecops'
    }

    // Verifica se existe
    const hasFee = await FeeCase.exists({ _id: feeId })
    if (!hasFee) {
      return Result.fail('Fee case not found')
    }

    // Carrega do banco e converte em objeto
    const feeCase = await (await FeeCase.findById(feeId)).toObject()

    // Injetamos manualmente a documentUrl
    feeCase.documentUrl = getDocumentUrl()

    // Caso possua defaultPackageType, branchType, etc., podemos adicioná-los também
    // feeCase.branchType = ...
    // feeCase.defaultPackageType = ...
    // feeCase.feePackage = ...
    // Exemplo (caso feeCase já tenha, ou venha de outro local):
    // feeCase.branchType = feeCase.branchType || 'Domestic'
    // feeCase.defaultPackageType = feeCase.defaultPackageType || 'Individual'

    // feesActives
    const feesActives = await FeeCase.find({
      cif: feeCase.cif,
      status: { $nin: ['DONE', 'REJECTED'] },
      caseNumber: { $exists: true }
    })

    feeCase.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id
    }))

    // Se status != 'INITIAL' ou 'PENDING_APPROVAL', processa exceções
    if (!['INITIAL', 'PENDING_APPROVAL'].includes(feeCase.status)) {
      feeCase.fees.forEach((fee) => {
        fee.feeGroups.forEach((feeGroup) => {
          if (feeGroup.name !== 'Exception Request') return

          const lastField = feeGroup.fields.slice(-1)[0]
          const lastOption = lastField.exceptionOptions.slice(-1)[0]

          const commonApprover = feeCase.usersApprovers.find((user) => user.result)
          if (commonApprover) {
            feeGroup.approvalResults = processCommonApprover(feeCase, feeGroup, commonApprover)
          }

          resetLastFieldBasedOnConditions(lastField, lastOption, feeCase)
        })
      })
    }

    // Se o usuário dono do case é o userName
    if (feeCase?.userOwner?.toUpperCase() === userName?.toUpperCase()) {
      feeCase.canApprove = false
      return Result.ok(feeCase)
    }

    // Qual a lista que contém este user no status atual
    const userListProperty = strategyForStatus[feeCase.status]
    const canApproveProperty = strategyForApprover[feeCase.status]

    // Verifica se userName está no userListProperty
    if (
      feeCase[userListProperty] &&
      feeCase[userListProperty].some(
        (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
      )
    ) {
      feeCase[canApproveProperty] = true

      // Se 'PENDING_APPROVAL' e signature AAA => canSeeRevenueReport
      if (
        feeCase.status === 'PENDING_APPROVAL' &&
        feeCase[userListProperty]
          .filter((x) => x.userName?.toUpperCase() === userName?.toUpperCase())[0]
          ?.signature.includes('AAA')
      ) {
        feeCase.canSeeRevenueReport = true
      }

      return Result.ok(feeCase)
    }

    // Se não está, checamos se pode "ver" (canSeeCase)
    const propertys = Object.keys(strategyForStatus)
    let canSeeCase = false
    for (const property of propertys) {
      const userProperty = strategyForStatus[property]
      if (
        feeCase[userProperty] &&
        feeCase[userProperty].some(
          (x) => x.userName?.toUpperCase() === userName?.toUpperCase()
        )
      ) {
        canSeeCase = true
        break
      }
    }

    if (canSeeCase) {
      return Result.ok(feeCase)
    }

    return Result.fail('Not found')
  }
}
