import Result from '#features/shared/result.js';
import CustomerFees from '#src/models/CustomerFees.js';
import BankAccountFee from '#src/models/BankAccountFee.js';
import { FeeCase } from '#src/models/entities/FeeCase.js';
import {
  connectToFeeMgmtDb,
  executeStoreProcedure,
} from '#core/data/mssql/index.js';

//
// Mapeamento FeeCode => code (números)
//
const deParaFeeCodes = {
  JH001: 1,
  JH002: 2,
  JH006: 4,
  JH007: 8,
  BPS002: 6,
  BPS003: 5,
  BPS004: 7,
  BPS005: 7,
  JH010: 3,
};

//
// Determinados FeeCodes que serão excluídos/ignorados
//
const excludedCodes = new Set([8]);

//
// Mapeia o FeeType retornado pelo DB para o FeeType usado na aplicação
// ex: se no DB vem "Client Fees" mas no app chamamos "Customer Fees"
//
function mapDbFeeTypeToApp(feeTypeFromDb) {
  switch (feeTypeFromDb) {
    case 'Client Fees':
      return 'Customer Fees';
    case 'Bank Account Fees':
      return 'Bank Account Fees';
    case 'Investment Account Fees':
      return 'Investment Account Fees';
    default:
      // fallback caso o DB traga algo fora do esperado
      return feeTypeFromDb;
  }
}

//
// Mapeia strings de FeeType para IDs usados internamente (1,2,3,...)
//
function mapFeeTypeToNumber(feeType) {
  switch (feeType) {
    case 'Customer Fees':
      return 1;
    case 'Bank Account Fees':
      return 2;
    case 'Investment Account Fees':
      return 3;
    default:
      return 0;
  }
}

//
// Se precisar mapear ID do pacote para alguma URL de documento
//
function getDocumentUrl(feePackageId) {
  // Exemplo: se a global.environment.scheduleUrls tiver alguma relação
  // ou se tiver um map:
  // const packageKeyMap = { 1:'intlPB3', 2:'uSPBIndividual3', ... };
  // return ...;
  return ''; // Ajuste conforme sua lógica
}

//
// Classe principal
//
export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    const result = { fees: [] };

    // Obtém dados do SQL, incluindo groupedFees e accounts
    const { groupedFees, accounts } = await this.#getFeesStructuredFromSQL(
      customerAccount
    );

    // Monta "accounts" para o retorno final
    result.accounts = accounts.map((account) => ({
      cifno: account.cifno,
      ddaNumber: account.ddaNumber,
      branchCity: account.branchCity,
      branchState: account.branchState,
      branchType: account.branchType,
      defaultPackageType: account.defaultPackageType,
      feePackage: account.feePackage,
    }));

    // Exemplo de uso das classes CustomerFees e BankAccountFee
    const customer = new CustomerFees(groupedFees, accounts);
    if (customer.fee) result.fees.push(customer.fee);

    const bank = new BankAccountFee(groupedFees, accounts);
    if (bank.fee) result.fees.push(bank.fee);

    // Exemplo: "Investment Account Fees" (Se precisar de alguma lógica custom)
    const invGroup = groupedFees.find((g) => g.feeType === 'Investment Account Fees');
    if (invGroup) {
      // ...exemplo de alguma manipulação
      result.fees.push(invGroup);
    }

    // Busca Fees ativas (mongo, etc.)
    const feesActives = await FeeCase.find({
      cif: customerAccount[0].cifno,
      status: {
        $nin: ['DONE', 'REJECTED'],
      },
      caseNumber: {
        $exists: true,
      },
    });

    result.feesActives = feesActives?.map((x) => ({
      caseNumber: x.caseNumber,
      id: x.id,
    }));

    // Retorno final
    return Result.ok(result);
  }

  //
  // FUNÇÃO PRINCIPAL: agrupa fees e exceptions
  //
  async #getFeesStructuredFromSQL(customerAccount) {
    // 1) Busca os fees "normais"
    const feesData = await this.#getFeesFromSQL(customerAccount[0].cifno);
    if (!feesData || feesData.length === 0) {
      // Se não achou nada, retorne algo vazio ou lance erro
      return { groupedFees: [], accounts: [] };
    }

    // 2) Identifica o Default Fee Package Id (para buscar exceptions)
    const feePackageId = feesData[0]['Default Fee Package Id'];
    if (!feePackageId) {
      throw new Error('Default Fee Package Id not found in feesData');
    }

    // 3) Document URL (se precisar)
    const documentUrl = getDocumentUrl(feePackageId);

    // 4) Monta accounts
    const accounts = feesData.map((fee) => ({
      cifno: fee.CIFNO,
      ddaNumber: fee.ACCTNO,
      branchCity: fee['Branch City'],
      branchState: fee['Branch State'],
      branchType: fee['Branch Type'],
      defaultPackageType: fee['Default Package Type'],
      feePackage: fee['Default Fee Package']?.trim() || '',
      defaultFeePackageId: fee['Default Fee Package Id'] || '',
      feeType: mapFeeTypeToNumber(
        mapDbFeeTypeToApp(fee.FeeType)
      ), // ID numérico
      feeGroup: 1,
      kycMailingStatus: fee.StandardException === 'Standard' ? 'Standard' : 'Hold Mail',
      documentUrl,
    }));

    // 5) Cria um objeto para agrupar fees: { "Customer Fees": { feeType: "Customer Fees", feeGroups: [...] }, ... }
    const groupedFeesMap = {};

    // Lista de FeeTypes que você considera relevantes
    const possibleFeeTypes = [
      'Customer Fees',
      'Bank Account Fees',
      'Investment Account Fees'
    ];

    // Garante a existência dos feeTypes e dos grupos inicias
    for (const ft of possibleFeeTypes) {
      groupedFeesMap[ft] = {
        feeType: ft,
        feeGroups: [
          {
            name: 'Standard Fees',
            code: 1,
            fields: [],
          },
          {
            name: 'Client Current Fees',
            code: 2,
            fields: [],
          },
          {
            name: 'Exceptions Request',
            code: 3,
            fields: [],
          },
        ],
      };
    }

    // 6) Monta Standard Fees e Client Current Fees com base em feesData
    for (const row of feesData) {
      const feeTypeDb = row.FeeType; // ex: "Client Fees"
      const feeTypeApp = mapDbFeeTypeToApp(feeTypeDb); // ex: "Customer Fees"

      // Se esse feeType não estiver no possibleFeeTypes, skip
      if (!groupedFeesMap[feeTypeApp]) continue;

      const {
        FeeDescription,
        FeeCode,
        FeeAmount,
        Frequency,
        DefaultFeeAmount,
        DefaultFrequency,
      } = row;

      // Mapeia o code (FeeCode => int)
      const mappedCode = deParaFeeCodes[FeeCode] || FeeCode;

      // Exclui se estiver no excludedCodes
      if (excludedCodes.has(mappedCode)) continue;

      // Regras específicas (opcional) - ex.: se FeeType for "Customer Fees", mas code não está em [1,2], skip...
      // (depende da sua lógica, vou deixar igual seu código inicial)
      if (
        feeTypeApp === 'Customer Fees' && ![1, 2].includes(mappedCode) ||
        feeTypeApp === 'Bank Account Fees' && ![3, 4].includes(mappedCode) ||
        feeTypeApp === 'Investment Account Fees' && ![5, 6, 7].includes(mappedCode)
      ) {
        continue;
      }

      // Acessa o groupedFeesMap certo
      const groupObj = groupedFeesMap[feeTypeApp];
      const standardGroup = groupObj.feeGroups.find((g) => g.name === 'Standard Fees');
      const clientCurrentGroup = groupObj.feeGroups.find((g) => g.name === 'Client Current Fees');

      // Adiciona field no Standard Fees
      standardGroup.fields.push({
        code: mappedCode,
        name: FeeDescription,
        defaultValue: FeeAmount ? FeeAmount.toString() : '',
        tooltip: Frequency || '',
        isException: false,
        // se quiser exceptionOptions aqui (normalmente não):
        // exceptionOptions: []
      });

      // Adiciona field no Client Current Fees
      clientCurrentGroup.fields.push({
        code: mappedCode,
        name: FeeDescription,
        defaultValue: DefaultFeeAmount ? DefaultFeeAmount.toString() : '',
        tooltip: DefaultFrequency || '',
        isException: false,
      });
    }

    // 7) Busca exceptions do DB
    const exceptions = await this.#getExceptionFeesFromSQL(feePackageId);
    // exceptions deve conter algo do tipo:
    // [
    //   {
    //     feeType: "Customer Fees",
    //     code: 1,
    //     name: "Account Maintenance Fee",
    //     defaultValue: "0",
    //     parameterOptionId: 113,
    //     ...
    //   },
    //   ...
    // ]

    // 8) Agrupa as exceptions por feeType e code
    const exceptionsByFeeTypeAndCode = {};
    for (const exc of exceptions) {
      const feeTypeApp = exc.feeType;
      if (!exceptionsByFeeTypeAndCode[feeTypeApp]) {
        exceptionsByFeeTypeAndCode[feeTypeApp] = {};
      }
      const code = exc.code;
      if (!exceptionsByFeeTypeAndCode[feeTypeApp][code]) {
        exceptionsByFeeTypeAndCode[feeTypeApp][code] = [];
      }
      exceptionsByFeeTypeAndCode[feeTypeApp][code].push(exc);
    }

    // 9) Percorre possibleFeeTypes e insere as exceptionOptions no grupo "Exceptions Request"
    for (const ft of possibleFeeTypes) {
      const groupObj = groupedFeesMap[ft];
      if (!groupObj) continue;

      const exceptionGroup = groupObj.feeGroups.find((g) => g.name === 'Exceptions Request');
      if (!exceptionGroup) continue; // deve existir, mas por segurança

      // 9a) Descobre todos os codes que existem em Standard/Client
      // Se quiser que todos apareçam em Exceptions, mesmo sem exceptions do DB
      const standardCodes = groupObj.feeGroups
        .find((g) => g.name === 'Standard Fees')?.fields.map((f) => f.code) || [];
      const clientCodes = groupObj.feeGroups
        .find((g) => g.name === 'Client Current Fees')?.fields.map((f) => f.code) || [];
      const allCodes = new Set([...standardCodes, ...clientCodes]);

      // 9b) Cria um field para cada code (caso não exista)
      for (const code of allCodes) {
        let field = exceptionGroup.fields.find((f) => f.code === code);
        if (!field) {
          field = {
            code,
            name: '', // se quiser puxar do Standard/Client
            defaultValue: '0',
            tooltip: '',
            isException: true,
            exceptionOptions: []
          };
          exceptionGroup.fields.push(field);
        }
      }

      // 9c) Popula de fato as exceptionOptions (caso existam no DB)
      const codeMap = exceptionsByFeeTypeAndCode[ft] || {};
      for (const [codeStr, listExc] of Object.entries(codeMap)) {
        const code = Number(codeStr);
        // Acha/cria field
        let field = exceptionGroup.fields.find((f) => f.code === code);
        if (!field) {
          // cria se não existir
          field = {
            code,
            name: listExc[0].name || '',
            defaultValue: listExc[0].defaultValue || '0',
            tooltip: listExc[0].tooltip || '',
            isException: true,
            exceptionOptions: [],
          };
          exceptionGroup.fields.push(field);
        }

        // Agora adiciona cada opção no formato QA
        for (const exc of listExc) {
          const amountNumber = parseFloat(exc.defaultValue || '0');
          field.exceptionOptions.push({
            approvedByDoubleA: null,
            value: exc.defaultValue,            // ex: "600"
            text: `$${amountNumber.toFixed(2)}`, // ex: "$600.00"
            visible: true,
            retired: false,
            parameterOptionId: exc.parameterOptionId,
            // _id: se precisar criar um ID ou vir do DB
          });
        }
      }
    }

    // 10) Retorna
    // groupedFeesMap é um objeto, mas precisamos de array
    const groupedFees = Object.values(groupedFeesMap);
    return { groupedFees, accounts };
  }

  //
  // Conecta e chama SP que retorna fees. Ajuste o nome das colunas conforme seu DB
  //
  async #getFeesFromSQL(cifno) {
    const connection = await connectToFeeMgmtDb();
    return executeStoreProcedure(connection, 'sp_get_fees_byCIF', { cifno });
  }

  //
  // Conecta e chama SP que retorna exception fees, já convertendo FeeType e FeeCode
  //
  async #getExceptionFeesFromSQL(feePackageId) {
    const connection = await connectToFeeMgmtDb();
    const data = await executeStoreProcedure(
      connection,
      'sp_get_exception_fees_bypackage',
      { feePackageId }
    );
    // Ajuste os nomes das colunas conforme seu DB
    return data.map((exception) => {
      // Mapeia "exception.FeeType" do DB para "Customer Fees", etc.
      const feeTypeApp = mapDbFeeTypeToApp(exception.FeeType);

      return {
        feeType: feeTypeApp,
        code: deParaFeeCodes[exception.FeeCode] || exception.FeeCode,
        name: exception.FeeDescription,
        defaultValue: exception.Amount?.toString() || '0',
        tooltip: exception.FreqDescription || '',
        isException: true,
        parameterOptionId: exception.FeeParameterOptionId,
      };
    });
  }
}
