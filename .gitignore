async function processNewFiles(newFiles: File[]) {
  if (!newFiles.length) return;

  // Filtra duplicados por nome e aplica validação individual
  const toUpload = newFiles.filter((file) => {
    const duplicate = documentList.some(
      (doc) =>
        doc.documentName.replace(/\s/g, "_") === file.name.replace(/\s/g, "_")
    );
    if (duplicate) return false;                  // já existe

    return handleFileValidation(file);            // só segue se for válido
  });

  if (!toUpload.length) return;

  const batchUUID = documentList[0]?.documentUUID ?? uuid;

  // Faz upload de todos — cada um recebe sua signedURL
  const uploads = await Promise.all(
    toUpload.map(async (file) => {
      const resp = await handleUpload(file, batchUUID); // faz POST
      return { file, resp };
    })
  );

  // Mapeia respostas recebidas em UploadedDocument[]
  const uploadedDocs: UploadedDocument[] = uploads
    .filter(({ resp }) => resp)                  // descarta falhas
    .map(({ file, resp }) => ({
      itemRef: props.itemRef,
      documentName: file.name,
      documentSize: file.size,
      documentStatus: "uploaded",
      documentUUID: batchUUID,
      serverPath: resp!.serverPath,
      serverUrlSigned: resp!.serverUrlSigned,
      documentURL: URL.createObjectURL(file),
      documentURLPreview: URL.createObjectURL(file),
      uploadedBy: {
        fullName: props.userData.fullName,
        userId: props.userData.userName,
      },
      createdAt: new Date().toISOString(),
    }));

  if (!uploadedDocs.length) return;              // nada subiu

  // Atualiza store e estado local
  const merged = [...documentList, ...uploadedDocs];
  props.setDocumentList(merged);
  setFiles((prev) => [...prev, ...toUpload]);

  if (fileInputRef.current) fileInputRef.current.value = "";
  props.onError("Upload");
}
