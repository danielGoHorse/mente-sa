const possibleFeeTypes = [
  'Customer Fees',
  'Bank Account Fees',
  'Investment Account Fees'
];

for (const ft of possibleFeeTypes) {
  const groupObj = groupedFeesMap[ft];
  if (!groupObj) continue;

  const exceptionGroup = groupObj.feeGroups.find((g) => g.name === 'Exceptions Request');
  if (!exceptionGroup) continue; 

  // Exemplo: criação dos fields para Exceptions Request
  const standardGroup = groupedFeesMap[ft]?.feeGroups.find((g) => g.name === 'Standard Fees');
  
  // Aqui, você itera sobre os códigos presentes nos outros grupos:
  const standardCodes = groupObj.feeGroups
    .find((g) => g.name === 'Standard Fees')?.fields.map((f) => f.code) || [];
  const clientCodes = groupObj.feeGroups
    .find((g) => g.name === 'Client Current Fees')?.fields.map((f) => f.code) || [];
  const allCodes = new Set([...standardCodes, ...clientCodes]);

  for (const code of allCodes) {
    let field = exceptionGroup.fields.find((f) => f.code === code);
    if (!field) {
      // Se não existir, cria um novo campo
      const stdField = standardGroup?.fields.find((f) => f.code === code);
      field = {
        code,
        name: stdField?.name || '',
        defaultValue: '0',
        tooltip: '',
        isException: true,
        exceptionOptions: []
      };
      exceptionGroup.fields.push(field);
    }
  }

  // Processa as exceptions para atualizar ou criar os fields
  const codeMap = exceptionsByFeeTypeAndCode[ft] || {};
  for (const [codeStr, listExc] of Object.entries(codeMap)) {
    const code = Number(codeStr);
    let field = exceptionGroup.fields.find((f) => f.code === code);
    if (!field) {
      const standardGroup = groupedFeesMap[ft]?.feeGroups.find((g) => g.name === 'Standard Fees');
      const stdField = standardGroup?.fields.find((f) => f.code === code);
      field = {
        code,
        name: stdField?.name || '',
        defaultValue: listExc[0].defaultValue || '0',
        tooltip: listExc[0].tooltip || '',
        isException: true,
        exceptionOptions: []
      };
      exceptionGroup.fields.push(field);
    } else {
      if (!field.name || field.name.trim() === '') {
        const standardGroup = groupedFeesMap[ft]?.feeGroups.find((g) => g.name === 'Standard Fees');
        const stdField = standardGroup?.fields.find((f) => f.code === code);
        field.name = stdField?.name || listExc[0].name || '';
      }
    }
    for (const exc of listExc) {
      const amountNumber = parseFloat(exc.defaultValue || '0');
      field.exceptionOptions.push({
        approvedByDoubleA: null,
        value: exc.defaultValue,
        text: `$${amountNumber.toFixed(2)}`,
        visible: true,
        retired: false,
        parameterOptionId: exc.parameterOptionId,
      });
    }
  }
}
