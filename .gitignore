import { HistoryData } from "../store/types";

type RawHistory = {
  status?: string;
  data?: any[][];
  workflow?: any[][];
  cardRowData?: any[];
  dataDisplayData?: any[];
  selectedBank?: string;
};

export function parseHistoryToData(history: RawHistory): HistoryData {
  if (!history || !Array.isArray(history.data)) {
    return {
      status: history?.status ?? "",
      data: [],
      cardRowData: [],
      dataDisplayData: [],
      selectedBank: "",
    };
  }

  // Achando os steps internos do grupo
  const allSteps = history.data.flat();
  const approvalsSteps = allSteps.filter(s =>
    s.name && s.name.startsWith("Approvals and Restrictions")
  );
  const otherSteps = allSteps.filter(
    s => !s.name?.startsWith("Approvals and Restrictions")
  );

  // Step agrupado (com os internos)
  let approvalsStep = null;
  if (approvalsSteps.length) {
    const status =
      approvalsSteps.find(s => s.status === "pending")?.status ||
      approvalsSteps[0]?.status ||
      "pending";
    approvalsStep = {
      id: 9999,
      name: "Approvals and Restrictions",
      status,
      successLabel: "Approved",
      permissions: { people: [] },
      internalSteps: approvalsSteps,
    };
  }

  // Monta a timeline: insere o agrupado na posição original do primeiro substep agrupado
  const stepsFinal: any[] = [];
  let inserted = false;
  for (let i = 0; i < otherSteps.length; i++) {
    const s = otherSteps[i];
    // Insere o step agrupador após "Validate Workflow" ou antes de "Restriction Removal"
    if (
      !inserted &&
      approvalsStep &&
      (s.name === "Validate Workflow" ||
        (otherSteps[i + 1] &&
          otherSteps[i + 1].name === "Restriction Removal"))
    ) {
      stepsFinal.push(approvalsStep);
      inserted = true;
    }
    stepsFinal.push(s);
  }
  // Caso não tenha sido inserido, coloca no final
  if (!inserted && approvalsStep) stepsFinal.push(approvalsStep);

  // Monta o array igual seu mock (cada step em um array)
  const mockData = stepsFinal.map(item => [item]);

  return {
    status: history.status ?? "",
    data: mockData,
    cardRowData: history.cardRowData ?? [],
    dataDisplayData: history.dataDisplayData ?? [],
    selectedBank: history.selectedBank ?? "",
  };
}
