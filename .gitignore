const codeMap = exceptionsByFeeTypeAndCode[ft] || {};
for (const [codeStr, listExc] of Object.entries(codeMap)) {
  const code = Number(codeStr);
  let field = exceptionGroup.fields.find((f) => f.code === code);
  if (!field) {
    // Se o field ainda não existe, crie-o usando o nome da exception ou do grupo padrão.
    let fieldName = listExc[0].name;
    if (!fieldName) {
      const standardGroup = groupedFeesMap[ft]?.feeGroups.find((g) => g.name === 'Standard Fees');
      const stdField = standardGroup?.fields.find((f) => f.code === code);
      fieldName = stdField?.name || '';
    }
    field = {
      code,
      name: fieldName,
      defaultValue: listExc[0].defaultValue || '0',
      tooltip: listExc[0].tooltip || '',
      isException: true,
      exceptionOptions: [],
    };
    exceptionGroup.fields.push(field);
  } else {
    // Se o field já existe mas o name está vazio, atualize-o
    if (!field.name || field.name.trim() === '') {
      let fieldName = listExc[0].name;
      if (!fieldName) {
        const standardGroup = groupedFeesMap[ft]?.feeGroups.find((g) => g.name === 'Standard Fees');
        const stdField = standardGroup?.fields.find((f) => f.code === code);
        fieldName = stdField?.name || '';
      }
      field.name = fieldName;
    }
  }
  // Adiciona as opções de exception para este field
  for (const exc of listExc) {
    const amountNumber = parseFloat(exc.defaultValue || '0');
    field.exceptionOptions.push({
      approvedByDoubleA: null,
      value: exc.defaultValue,
      text: `$${amountNumber.toFixed(2)}`,
      visible: true,
      retired: false,
      parameterOptionId: exc.parameterOptionId,
    });
  }
}
