/* eslint‑disable no-console */
import { Fee }                     from '#src/models/entities/Fees.js';
import Result                      from '#features/shared/result.js';
import CustomerFees                from '#src/models/CustomerFees.js';
import BankAccountFee              from '#src/models/BankAccountFee.js';
import InvestimentAccountFee       from '#src/models/InvestimentAccountFee.js';
import { FeeCase }                 from '#src/models/entities/FeeCase.js';
import { Field }                   from '#src/models/entities/Fields.js';
import numberToCurrency            from '#core/helpers/currency.js';
import {
  connectToFeeMgmtDb,
  executeStoreProcedure,
} from '#core/data/mssql/index.js';


async function getPackageData(cifno) {
  const conn  = await connectToFeeMgmtDb();
  const [row] = await executeStoreProcedure(conn, 'sp_get_fees_byCIF', { cifno });
  if (!row) return {};

  return {
    defaultFeePackageId : row['Default Fee Package Id'] ?? null,
    branchCity          : row['Branch City']?.trim()          || '',
    branchState         : row['Branch State']?.trim()         || '',
    branchType          : row['Branch Type']?.trim()          || '',
    defaultPackageType  : row['Default Package Type']?.trim() || '',
    feePackage          : row['Default Fee Package']?.trim()  || '',
  };
}

async function getStandardFees(packageId) {
  const conn = await connectToFeeMgmtDb();
  const rows = await executeStoreProcedure(
    conn, 'sp_get_standard_fees_bypackage',
    { FeePackageId: packageId },
  );
  console.log('STD‑rows', rows?.length);
  return rows ?? [];
}

async function getExceptionFees(packageId) {
  const conn = await connectToFeeMgmtDb();
  const rows = await executeStoreProcedure(
    conn, 'sp_get_exception_fees_bypackage',
    { FeePackageId: packageId },
  );
  console.log('EXC‑rows', rows?.length);
  return rows ?? [];
}

function getDocumentUrl(id) {
  const urls = global.environment.scheduleUrls || {};
  const key  = ({ 1: 'intlPB3', 2: 'uSPBIndividual3', 3: 'uSPBCorporation3' })[id];
  return key ? urls[key] || '' : '';
}


async function getFeeStandard(filter) {
  return Fee.find({ $or: filter })
            .select({ feeType: 1, feeGroups: { name: 1, fields: 1, code: 1 } })
            .lean();
}

function findGroup(fee, name) {
  return fee?.feeGroups?.find((g) => g.name === name);
}

const feeCodeMap = {
  JH001: 1, JH002: 2, JH010: 3, JH008: 4,
  BPS002: 6, BPS003: 5, BPS004: 7, BPS005: 7,
};

function applyStandardAmounts(mongoFees, stdRows) {
  mongoFees.forEach(fee => {
    const stdGrp = findGroup(fee, 'Standard Fees');
    if (!stdGrp) return;

    stdGrp.fields.forEach(field => {
      const row = stdRows.find(r => Number(r.FeeType) === field.code);
      if (!row) return;

      const num = Number(row.FeeAmount);

      field.defaultValue = num.toString();         
        field.labelValue   = numberToCurrency(num); 

      field.tooltip = row.FrequencyDescription?.trim() || "";              
    });
  });
}

function applyExceptionAmounts(mongoFees, excRows) {
  const byCode = excRows.reduce((acc, r) => {
    (acc[r.FeeCode] ??= []).push(r);
    return acc;
  }, {});

  mongoFees.forEach(fee => {
    const excGrp = findGroup(fee, 'Exception Request');
    if (!excGrp) return;

    excGrp.fields.forEach(field => {
      const code = Object.entries(feeCodeMap)
                         .find(([, c]) => c === field.code)?.[0];
      const rows = code ? byCode[code] : null;
      if (!rows?.length) return;

      /* ❶ separa numéricos e texto ❷ ordena ❸ concatena */
      const nums = rows.filter(r => !Number.isNaN(Number(r.Amount)))
                       .sort((a, b) => Number(a.Amount) - Number(b.Amount));
      const alpha = rows.filter(r => Number.isNaN(Number(r.Amount)))
                        .sort((a, b) => a.Amount.localeCompare(b.Amount));

      field.exceptionOptions = [...nums, ...alpha].map(r => ({
        value  : r.Amount,
        text   : Number.isNaN(Number(r.Amount))
                   ? (r.FreqDescription?.trim() || r.Amount)
                   : numberToCurrency(Number(r.Amount)),
        visible: true,
        retired: false
      }));

      field.defaultValue = '';
      field.labelValue   = '';
    });
  });
}

function syncExceptionLabels(feesArr) {
  feesArr.forEach((fee) => {
    const exc = findGroup(fee, 'Exception Request');
    if (!exc) return;
    exc.fields.forEach((f) => {
      const val = f.defaultValue;
      f.labelValue = val ? numberToCurrency(Number(val)) : '';
    });
  });
}


export default class FeeGetByCifUseCase {
  async execute({ customerAccount }) {
    const fees = await getFeeStandard([
      { feeType: 'Customer Fees' },
      { feeType: 'Bank Account Fees' },
      { feeType: 'Investment Account Fees' },
    ]);

    const pkgData   = await getPackageData(customerAccount[0].cifno);
    const packageId = pkgData.defaultFeePackageId;

    const stdRows = await getStandardFees(packageId);
    const excRows = await getExceptionFees(packageId);

    applyStandardAmounts (fees, stdRows);
    applyExceptionAmounts(fees, excRows);

    customerAccount.forEach((acc) => Object.assign(acc, pkgData));

    const custodyAcc = customerAccount.find((a) => a.feeType === 6);
    if (custodyAcc) {
      const invFee   = fees.find((f) => f.feeType === 'Investment Account Fees');
      const currGrp  = findGroup(invFee, 'Client Current Fees');
      const custodyF = currGrp?.fields?.find((fl) => fl.code === 6);
      if (custodyF) {
        custodyF.defaultValue = custodyAcc.feeAmount.toString();   // "375"
        custodyF.labelValue   = numberToCurrency(custodyAcc.feeAmount); // "$375.00"
      }
    }

    const result = { fees: [] };

    const [customer, bank, investment] = [
      new CustomerFees(fees, customerAccount),
      new BankAccountFee(fees, customerAccount),
      new InvestimentAccountFee(
        fees, customerAccount, await Field.findOne({ code: 7 }),
      ),
    ];

    [customer, bank, investment]
      .filter((f) => f.fee && f.fee.feeGroups?.length)
      .forEach((f) => result.fees.push(f.fee));

    const actives = await FeeCase.find({
      cif       : customerAccount[0].cifno,
      status    : { $nin: ['DONE', 'REJECTED'] },
      caseNumber: { $exists: true },
    });
    result.feesActives = actives.map(({ caseNumber, id }) => ({ caseNumber, id }));

    const docUrl = getDocumentUrl(packageId);
    result.accounts = customerAccount.map((acc) => ({
      cifno              : acc.cifno,
      ddaNumber          : acc.ddaNumber,
      branchCity         : acc.branchCity,
      branchState        : acc.branchState,
      branchType         : acc.branchType,
      defaultPackageType : acc.defaultPackageType,
      feePackage         : acc.feePackage,
      defaultFeePackageId: acc.defaultFeePackageId,
      defaultFeePackage  : acc.defaultFeePackage,
      documentUrl        : docUrl,
      feeAmount          : acc.feeAmount,
      exceptionAmount    : acc.exceptionAmount ?? null,
    }));
    result.documentUrl = docUrl;

    syncExceptionLabels(result.fees);

    (function patchCustodyCurrent() {
      const invFee   = result.fees.find(f => f.feeType === 'Investment Account Fees');
      if (!invFee) return;
    
      const currGrp  = invFee.feeGroups?.find(g => g.name === 'Client Current Fees');
      const custodyF = currGrp?.fields?.find(fl => Number(fl.code) === 6);
      if (!custodyF) return;
    
      const custodyAcc = customerAccount.find(a => a.feeType === 6);
      if (!custodyAcc) return;
    
      custodyF.defaultValue = custodyAcc.feeCode;                
      custodyF.labelValue   = numberToCurrency(custodyAcc.feeAmount); 
    })();
    
    return Result.ok(result);

  }
}




Bruno Aguiar
05/14/2025 3:19 PM
eu mexi no campo fee amount
para trazer os códigos do equity e safekeep
acho que o chibly consegue te explicar
You
05/14/2025 3:33 PM
Ok, mas isso vc acha que me impacta de alguma forma?
(PRecisei ir tomar uma agua .... agora vou testar novamente)
Bruno Aguiar
05/14/2025 3:36 PM
sim, o nome que é pra ser exibido no dropdown
que é o mesmo fformato que ta sendo exibido agora no client current fees
<Código> - <descrição>
sendo que a descrição para o Equity and Options commision é:
"Equity: <descrição equity>; Option: <descrição option>"


CIFNO	DDANumber	BPSAcctNumber	FeeType	FeeDescription	FeeCode	BPSFeeTypeCode	FeeAmount	Source	Entity	IsFeesStandard
NAA0010	17226444		1	AccountMaintenance	JH001		1500.000000000	JHA	SNB/284	Yes
NAA0010	17226444		2	HoldMail	JH002		600.000000000	JHA	SNB/284	Yes
NAA0010	17226444		4	USD/FXOutgoingWire	JH008		20.000000000	JHA	SNB/284	No
NAA0010	17226444    	20103939	5	SSLMaintenanace	BPS003	S	0.000000000	BPS	SSL/189	No
NAA0010	17226444    	20002089	6	SafekeepingCustody	BPS002	C	375.000000000	BPS	SNB/284	Yes
NAA0010	17226444    	20103939	7	EquityCommissions	BPS004	E	0.000000000	BPS	SSL/189	Yes
NAA0010	17226444    	20103939	7	OptionsCommissions	BPS005	O	0.000000000	BPS	SSL/189	Yes
