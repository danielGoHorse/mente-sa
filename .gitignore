
import { Fee } from '#src/models/entities/Fees.js';
import Result from '#features/shared/result.js';
import CustomerFees from '#src/models/CustomerFees.js';
import BankAccountFee from '#src/models/BankAccountFee.js';
import InvestimentAccountFee from '#src/models/InvestimentAccountFee.js';
import { FeeCase } from '#src/models/entities/FeeCase.js';
import { Field } from '#src/models/entities/Fields.js';
import numberToCurrency from '#core/helpers/currency.js';
import {
  connectToFeeMgmtDb,
  executeStoreProcedure
} from '#core/data/mssql/index.js';


async function getPackageData(cifno) {
  const conn = await connectToFeeMgmtDb();
  const [row] = await executeStoreProcedure(conn, 'sp_get_fees_byCIF', { cifno });
  if (!row) return {};
  return {
    defaultFeePackageId: row['Default Fee Package Id'] ?? null,
    branchCity: row['Branch City']?.trim() || '',
    branchState: row['Branch State']?.trim() || '',
    branchType: row['Branch Type']?.trim() || '',
    defaultPackageType: row['Default Package Type']?.trim() || '',
    feePackage: row['Default Fee Package']?.trim() || '',
  };
}

async function getStandardFees(packageId) {
  const conn = await connectToFeeMgmtDb();
  const rows = await executeStoreProcedure(
    conn, 'sp_get_standard_fees_bypackage',
    { FeePackageId: packageId });
  console.log('STD‑rows', rows?.length);
  return rows ?? [];
}

async function getExceptionFees(packageId) {
  const conn = await connectToFeeMgmtDb();
  const rows = await executeStoreProcedure(
    conn, 'sp_get_exception_fees_bypackage',
    { FeePackageId: packageId });
  console.log('EXC‑rows', rows?.length);
  return rows ?? [];
}

function getDocumentUrl(id) {
  const urls = global.environment.scheduleUrls || {};
  const key = ({ 1: 'intlPB3', 2: 'uSPBIndividual3', 3: 'uSPBCorporation3' })[id];
  return key ? urls[key] || '' : '';
}


async function getFeeStandard(filter) {
  return Fee.find({ $or: filter })
    .select({ feeType: 1, feeGroups: { name: 1, fields: 1, code: 1 } })
    .lean();
}

function findGroup(fee, groupName) {
  return fee?.feeGroups?.find(g => g.name === groupName);
}

const feeCodeMap = { JH001: 1, JH002: 2, JH010: 3, JH008: 4 };

function applyStandardAmounts(mongoFees, stdRows) {
  mongoFees.forEach(fee => {
    const stdGrp = findGroup(fee, 'Standard Fees');
    if (!stdGrp) return;

    stdGrp.fields.forEach(field => {
      const row = stdRows.find(r => parseInt(r.FeeType, 10) === field.code);
      if (!row) return;

      const amt = Number(row.FeeAmount);

      field.defaultValue = '';
      field.labelValue = '';
    });
  });
}

function applyExceptionAmounts(mongoFees, excRows) {
  const map = { JH001: 1, JH002: 2, JH010: 3, JH008: 4 };

  const byCode = excRows.reduce((acc, r) => {
    (acc[r.FeeCode] ??= []).push(r);
    return acc;
  }, {});

  mongoFees.forEach(fee => {
    const excGrp = findGroup(fee, 'Exception Request');
    if (!excGrp) return;

    excGrp.fields.forEach(field => {
      const code = Object.entries(map).find(([, c]) => c === field.code)?.[0];
      const rows = code ? byCode[code] : null;
      if (!rows?.length) return;

      field.exceptionOptions = rows.map(r => ({
        value: Number(r.Amount).toString(),
        text: numberToCurrency(r.Amount),
        visible: true,
        retired: false
      }));

      field.defaultValue = '';
      field.labelValue = '';
    });
  });
}

function syncExceptionLabels(feesArray) {
  feesArray.forEach(fee => {
    const excGroup = fee.feeGroups?.find(
      g => g.name === 'Exception Request'
    );
    if (!excGroup) return;

    excGroup.fields.forEach(f => {
      const val = f.defaultValue;        
      f.labelValue = val
        ? numberToCurrency(Number(val))
        : '$0.00';                      
    });
  });
}

export default class FeeGetByCifUseCase {

  async execute({ customerAccount }) {
    const fees = await getFeeStandard([
      { feeType: 'Customer Fees' },
      { feeType: 'Bank Account Fees' },
      { feeType: 'Investment Account Fees' }
    ]);

    const pkgData = await getPackageData(customerAccount[0].cifno);
    const packageId = pkgData.defaultFeePackageId;   // fallback

    const stdRows = await getStandardFees(packageId);
    const excRows = await getExceptionFees(packageId);

    applyStandardAmounts(fees, stdRows);
    applyExceptionAmounts(fees, excRows);

    customerAccount.forEach(acc => {
      Object.assign(acc, pkgData);

      const std = stdRows.find(r => Number(r.FeeType) === acc.feeType);
      if (std) acc.feeAmount = Number(std.FeeAmount);

      const exc = excRows.find(e => e.FeeCode === acc.feeCode);
      if (exc) acc.exceptionAmount = Number(exc.Amount);
    });

    const result = { fees: [] };
    const [customer, bank, investment] = [
      new CustomerFees(fees, customerAccount),
      new BankAccountFee(fees, customerAccount),
      new InvestimentAccountFee(
        fees, customerAccount, await Field.findOne({ code: 7 }))
    ];

    [customer, bank, investment]
      .filter(f => f.fee && f.fee.feeGroups?.length)
      .forEach(f => result.fees.push(f.fee));

    const actives = await FeeCase.find({
      cif: customerAccount[0].cifno,
      status: { $nin: ['DONE', 'REJECTED'] },
      caseNumber: { $exists: true }
    });

    result.feesActives = actives.map(({ caseNumber, id }) => ({ caseNumber, id }));

    const docUrl = getDocumentUrl(packageId);
    result.accounts = customerAccount.map(acc => ({
      cifno: acc.cifno,
      ddaNumber: acc.ddaNumber,
      branchCity: acc.branchCity,
      branchState: acc.branchState,
      branchType: acc.branchType,
      defaultPackageType: acc.defaultPackageType,
      feePackage: acc.feePackage,
      defaultFeePackageId: acc.defaultFeePackageId,
      defaultFeePackage: acc.defaultFeePackage,
      documentUrl: docUrl,
      feeAmount: acc.feeAmount,
      exceptionAmount: acc.exceptionAmount ?? null
    }));

    result.documentUrl = docUrl;

    syncExceptionLabels(result.fees);

    return Result.ok(result);
  }
}
