import { FeeGroup } from './entities/FeeGroups.js';
import numberToCurrency from '../core/helpers/currency.js';

export default class BankAccountFee {
  #feeName = 'Bank Account Fees';
  #bank = {};
  #accounts = [];
  #accountsDDA = [];

  constructor(fees, accounts) {
    if (!fees || !Array.isArray(fees) || fees.length === 0) {
      throw new Error('Fees is empty or undefined');
    }

    // Seleciona os dados do fee do tipo Bank Account Fees
    this.#bank = fees.filter((x) => x.feeType === this.#feeName)[0];
    if (!this.#bank || !Array.isArray(this.#bank.feeGroups)) {
      throw new Error('Bank Account Fees or feeGroups are undefined');
    }

    if (!accounts || !Array.isArray(accounts) || accounts.length === 0) {
      throw new Error('Accounts is empty or undefined');
    }

    const feeGroupCode = this.#bank.feeGroups[0].code;
    // Filtra as contas que pertencem ao grupo e deduplica com base no número de conta (ddaNumber)
    const accountsFiltered = accounts.filter((x) => x.feeGroup === feeGroupCode);
    this.#accounts = Array.from(
      new Map(accountsFiltered.map((a) => [a.ddaNumber, a])).values()
    );
    // Obtém os números de conta de forma única (já em string)
    this.#accountsDDA = this.#accounts.map((a) => a.ddaNumber.toString());

    if (this.#accounts.length === 0) {
      throw new Error('No accounts matched with Bank Account Fees feeGroup');
    }

    // Cria os feeGroups para cada conta única
    this.#addMultiplesAccount(this.#accounts[0].cifno);
    // Atualiza os valores de cada fee com os dados do cliente
    this.#addCurrentClientValue();
  }

  /**
   * Função auxiliar para deduplicar os campos (fields) com base no fee code.
   *
   * @param {Array} fields - Array de fields a serem deduplicados.
   * @returns {Array} - Array de fields sem duplicação.
   */
  #deduplicateFields(fields) {
    const map = new Map();
    for (const field of fields) {
      // Se já existir um field com o mesmo código, ignora os subsequentes
      if (!map.has(field.code)) {
        map.set(field.code, field);
      }
    }
    return Array.from(map.values());
  }

  /**
   * Para cada conta única, gera um novo conjunto de feeGroups a partir dos templates
   * existentes, atribuindo o número da conta (accountNumber) adequadamente, e removendo
   * duplicatas de fees (baseadas no fee code).
   *
   * @param {string} cif - O CIF da conta.
   */
  #addMultiplesAccount(cif) {
    if (!this.#accounts || this.#accounts.length < 1) {
      this.#bank = {};
      return;
    }

    // Utiliza os feeGroups originais como template
    const feeGroupTemplates = this.#bank.feeGroups;
    const newFeeGroups = [];

    // Para cada conta única, cria um feeGroup para cada template
    for (const account of this.#accounts) {
      const accountNumber = account.ddaNumber.toString();
      for (const template of feeGroupTemplates) {
        // Clona os fields para evitar referências compartilhadas
        let clonedFields = template.fields.map((field) => ({
          ...field,
          exceptionOptions: field.exceptionOptions
            ? field.exceptionOptions.map((opt) => ({ ...opt }))
            : []
        }));

        // Deduplica os campos com base no fee code
        clonedFields = this.#deduplicateFields(clonedFields);

        const newFeeGroup = new FeeGroup({
          name: template.name,
          fields: clonedFields,
          cif,
          accountNumber,
          visible: template.visible,
          code: template.code
        });
        newFeeGroups.push(newFeeGroup);
      }
    }

    this.#bank.feeGroups = newFeeGroups;
  }

  /**
   * Atualiza os valores dos fees para cada grupo, definindo o labelValue com base no valor
   * e vinculando o grupo à conta correta.
   */
  #addCurrentClientValue() {
    if (!this.#accounts || this.#accounts.length < 1) {
      this.#bank = {};
      return;
    }

    for (const [feeGroupIndex, feeGroup] of this.#bank.feeGroups.entries()) {
      feeGroup.cif = this.#accounts[0]?.cifno || null;
      for (const [fieldIndex, field] of feeGroup.fields.entries()) {
        if (field.isException) {
          const previousGroup = this.#bank.feeGroups[feeGroupIndex - 1];
          if (previousGroup) {
            field.labelValue = previousGroup.fields[fieldIndex]?.labelValue || '';
          }
        } else {
          for (const account of this.#accounts) {
            if (
              field.code === account.feeType &&
              feeGroup.accountNumber === account.ddaNumber.toString()
            ) {
              if (field.isCurrentClient) {
                field.defaultValue = account.feeAmount?.toString() || '';
              }
              field.labelValue = numberToCurrency(field.defaultValue);
            }
          }
        }
      }
    }

    this.#clearMemory();
  }

  get fee() {
    return this.#bank;
  }

  #clearMemory() {
    this.#accounts = [];
    this.#accountsDDA = [];
  }
}
