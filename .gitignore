import Result from '#features/shared/result.js';

export default class FeeCaseGetByCifUseCase {
  async execute({ cif }, feeManagementModel, customerModel) {
    const [errCustomer, responseCustomer] = await customerModel.getCustomerDetailsByCif(cif);
    if (errCustomer) {
      return Result.fail({ message: "It's not possible to get address cif" });
    }

    const customerData = responseCustomer?.data?.customer || {};
    const [errFee, responseFee] = await feeManagementModel.getFeeByAccount(customerData);
    if (errFee) {
      return Result.fail({ message: "It's not possible to get fee values" });
    }

    function normalizeFeeName(text) {
      return text
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/[_-]/g, ' ')
        .trim();
    }

    // Função para unificar a estrutura dos campos
    // Garantindo que todos tenham "defaultValue", "labelValue", "isException", etc.
    function unifyFieldShape(field, timestamp) {
      const newField = {
        code: field.code || "",
        name: field.name || "",
        // Se vier "amount", convertendo para string e formatando labelValue
        // Senão, se vier "defaultValue", mantemos
        defaultValue: field.defaultValue ?? "",
        labelValue: field.labelValue ?? "",
        isException: field.isException || false,
        exceptionOptions: field.exceptionOptions || [],
        hasChanged: field.hasChanged || false,
        createdAt: field.createdAt || timestamp,
        updatedAt: field.updatedAt || timestamp,
        id: field.id || ""
      };

      // Se veio "amount", preferimos transformá-lo em defaultValue e labelValue:
      if (typeof field.amount === "number") {
        newField.defaultValue = String(field.amount);
        newField.labelValue = field.amount > 0 ? `$${field.amount.toFixed(2)}` : "";
      }
      // Se vier "isStandard", "isCurrentClient" etc. do "client current fees",
      // você pode mesclar também
      if (field.isStandard !== undefined) {
        newField.isStandard = field.isStandard;
      } else {
        newField.isStandard = false;
      }
      if (field.isCurrentClient !== undefined) {
        newField.isCurrentClient = field.isCurrentClient;
      } else {
        newField.isCurrentClient = false;
      }
      if (field.tooltip) {
        newField.tooltip = field.tooltip;
      }
      if (field.defaultValue && !newField.labelValue) {
        // Se tem defaultValue mas não labelValue, crie se quiser:
        // newField.labelValue = `$${field.defaultValue}`; // ou outra lógica
      }

      // Outros campos específicos:
      // - "visible", "accountNumber", "cif", "kycMailingStatus", etc.
      // Se precisar deles em cada field, pode movê-los para cá também.

      return newField;
    }

    const feesData = responseFee?.data || {};
    const timestamp = new Date().toISOString();

    const packageName = feesData.feePackage || "N/A";
    const packageType = feesData.defaultPackageType || "N/A";
    const branchType = feesData.branchType || "N/A";

    const currentFees = [
      ...(customerData?.customerCurrentFees?.map(x => ({
        feeDescription: x.feeDescription || '',
        feeCode: x.feeCode || ''
      })) || []),
      ...(feesData?.currentFees || [])
    ];

    // Mapas
    const feeTypeMap = {
      1: "Customer Fees",
      2: "Bank Account Fees",
      3: "Investment Account Fees"
    };

    const feeCodeMap = {
      "Account Maintenance": 1,
      "Hold Mail": 2,
      "Incoming Wire": 3,
      "Outgoing Wire": 4,
      "Safekeeping Custody": 6,
      "SSL Account Maintenance": 5,
      "Equity and Options Commission": 7,
      "FX Outgoing Wire Fee": 8,
      "US Equities Commission": 10,
      "Options Commission": 11
    };

    // Filtrar accounts apenas dos FeeTypes de interesse
    const rawCustomerAccounts = customerData?.customerAccount || [];
    const filteredCustomerAccounts = rawCustomerAccounts.filter(fee => {
      const feeTypeString = feeTypeMap[fee.feeType] || "";
      return ["Customer Fees", "Bank Account Fees", "Investment Account Fees"].includes(feeTypeString);
    });

    // Montar formattedFees a partir do customer
    const formattedFees = filteredCustomerAccounts.map(fee => {
      const normalizedFeeName = normalizeFeeName(fee.feeDescription);
      return {
        feeType: feeTypeMap[fee.feeType] || "",
        feeGroups: [
          {
            name: fee.feeGroup === 1 ? "Client Current Fees" : "Standard Fees",
            // Se você quiser manter "code", "accountNumber", etc. no "fields" ou no "feeGroups", ajuste.
            visible: true,
            kycMailingStatus: fee.kycMailingStatus || null,
            code: fee.feeCode || "",
            accountNumber: fee.ddaNumber || "",
            cif: fee.cifno || "",
            id: "",
            fields: [
              unifyFieldShape(
                {
                  hasChanged: false,
                  code: feeCodeMap[normalizedFeeName] || fee.feeCode || "",
                  name: normalizedFeeName,
                  defaultValue: fee.feeAmount?.toString() || "",
                  isStandard: fee.isFeesStandard === "Yes",
                  isException: fee.isFeesStandard === "No",
                  isCurrentClient: false,
                  labelValue: fee.feeAmount ? `$${fee.feeAmount.toFixed(2)}` : "",
                  tooltip: fee.source ? `Source: ${fee.source}` : "",
                  exceptionOptions: [],
                  createdAt: timestamp,
                  updatedAt: timestamp,
                  id: fee.ddaNumber?.toString() || ""
                },
                timestamp
              )
            ]
          }
        ],
        id: ""
      };
    });

    // Montar formattedFeeGroups a partir de feesData
    const formattedFeeGroups =
      feesData?.fees
        ?.filter((fg) =>
          ["Customer Fees", "Bank Account Fees", "Investment Account Fees"].includes(fg.feeType)
        )
        .map((fg) => ({
          feeType: fg.feeType,
          id: "",
          feeGroups: fg.feeGroups.map((group) => ({
            ...group,
            id: group.id || "",
            cif: group.cif || "",
            accountNumber: group.accountNumber || "",
            fields: (group.fields || []).map((field) => unifyFieldShape(field, timestamp))
          }))
        })) || [];

    // Unir ambos
    const allFees = [...formattedFees, ...formattedFeeGroups];

    // FeeTypes finais
    const feeTypesToGroup = ["Customer Fees", "Bank Account Fees", "Investment Account Fees"];

    // Nomes de grupo possíveis
    const groupNames = ["Standard Fees", "Client Current Fees", "Exception Request"];

    const groupedFees = feeTypesToGroup.map((type) => {
      // 1) Filtra todos com esse feeType
      const itemsOfThisType = allFees.filter((item) => item.feeType === type);

      // 2) Concatena feeGroups
      const combinedFeeGroups = itemsOfThisType.flatMap((item) => item.feeGroups || []);

      // 3) Mapear name => array de fields
      const mapByName = {
        "Standard Fees": [],
        "Client Current Fees": [],
        "Exception Request": []
      };

      for (const group of combinedFeeGroups) {
        let groupName = group.name;
        if (!groupNames.includes(groupName)) {
          groupName = "Exception Request"; // se for outro nome, vira "Exception Request"
        }
        if (Array.isArray(group.fields)) {
          // Concatena todos os fields unificados
          mapByName[groupName].push(...group.fields);
        }
      }

      // 4) Montar array feeGroups
      let feeGroups = Object.entries(mapByName).map(([name, fields]) => ({
        name,
        fields
      }));

      // 5) Remover grupos que você NÃO quer se estiverem vazios
      //    Pelo que você disse, remover "Client Current Fees" ou "Exception Request" se vazios.
      //    Mas manter "Standard Fees" mesmo se vazio.
      feeGroups = feeGroups.filter((grp) => {
        if (grp.fields.length > 0) return true; // Se tem fields, fica
        // Se está vazio, só mantemos se não for Client Current nem Exception
        // (ou seja, se for "Standard Fees" vazio, deixa ficar)
        if (grp.name === "Client Current Fees" || grp.name === "Exception Request") {
          return false; // remover
        }
        return true; // caso seja Standard Fees vazio, mantemos
      });

      return {
        feeType: type,
        feeGroups
      };
    });

    const result = {
      customerName: customerData?.customerAddress?.name || feesData?.customerName || '',
      customerShortName: feesData?.customerShortName || '',
      customerAddress: customerData?.customerAddress?.address || '',
      customerAccountOfficer: customerData?.customerAddress?.officer || '',
      cif: customerData?.customerAddress?.cif || cif,
      officerId: feesData?.officerId || '',
      branchCity: feesData?.branchCity || '',
      branchState: feesData?.branchState || '',
      branchType,
      feePackage: feesData?.feePackage || '',
      defaultFeePackageId: feesData?.defaultFeePackageId || '',
      defaultPackageType: feesData?.defaultPackageType || '',
      packageName,
      packageType,
      fees: groupedFees,
      feesActives: feesData?.feesActives || [],
      documentUrl: feesData?.documentUrl || '',
      currentFees
    };

    global.logger.info('End process');
    return Result.ok(result);
  }
}
